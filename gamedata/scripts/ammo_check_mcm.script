-- AmmoCheck (Enhanced)
-- Original: https://github.com/RAX-Anomaly/AmmoCheck
-- Original Authors: Ishmaeel, RavenAscendant, ahuyn, Utjan
-- Last modified: 2022.08.17
-- 
-- Enhanced by: Abraham (Priler)
-- Enhanced from: 2025.12.10
-- Repository: https://github.com/Priler/AmmoCheck
-- 
-- Changes:
--   - Performance optimizations (cached globals, reduced HUD access calls) * more info below
--   - Fixed duplicate callback registration bug
--   - Added display mode setting (text/numeric/both)
--   - Added message duration settings
--   - Added auto-check after reload
--   - Added color intensity adjustment
--   - Added grenade mode checking toggle
--   - Added configurable busy hands delay
--   - Added independent debug mode toggle
--	 - Added additional ammo tags ([FMJ], [AP]), [HP], etc.) + highlight of ammo type/ammo tag (optional)
--   - Added "fake reload" mag inspect animation (taken & re-written from "OneKeyReload" mod)
--   - Added custom weapons animation settings (for example, now Toz-34 Chimera Hunter also has a badass ammo check animation)
--   - Added fake reload exclusion list (Mag Palming, etc. animations will be excluded)
--   - Added "Eject round on bolt cyrcle" option
--   - Added "Eject shell on pump slide" option

--  @TODO:
--   - No magazine fallback only works for weapons without mag inspect animation
--   - (reason: I dunno how to cancel mag inspect animation, as well as how to cancel camera movement animation alongside it)
--   - (so if anyone know how to do it, write me (issues on GH would be good, or comment on ModDB))

--[[
    Performance optimizations (LUA *magic*):
    - Cached global function lookups for direct access
    - Cache of different things (Ammo type classification, Translation strings, is_supported_weapon results)
    - Shared code where it's possible/required
    - Some GC targeted optimizations (as few hot path allocations as possible, as few closures as possible, etc.)
    ...
	- etc. idk I hate LUA tbh xD (tf arrays starts with 1)
    - probably some more extreme perf optimizations could be made
    - but honestly, I hate GC languages so .. it'll work
]]



-- Cached globals for performance --
local math_floor = math.floor
local math_min = math.min
local math_max = math.max
local math_ceil = math.ceil
local string_find = string.find
local string_lower = string.lower
local string_format = string.format
local string_match = string.match
local string_sub = string.sub

-- Forward declarations --
local gc = game.translate_string

-- Settings (defaults) --
local use_clr = true
local hide_counter = true
local hide_ammo_icon = true
local anim_mode = 2             -- 0: default (hide/show), 1: lower weapon, 2: fake reload
local mcm_key = DIK_keys.DIK_T
local msg_duration = 2
local show_ammo_type = false
local show_ammo_tag = true
local busy_hands_delay = 1
local no_magazine_fallback = 1  -- 0: hide/show, 1: lower, 2: none (for Fake Reload mode when no magazine loaded)
local fake_reload_fallback = 1  -- 0: hide/show, 1: lower (for internal mag weapons)
local fake_reload_bolt_cycle = true  -- Enable bolt cycle for bolt-action rifles
local fake_reload_bolt_eject = false -- Eject one round when cycling bolt (realism)
local fake_reload_pump_rack = true   -- Enable pump rack for pump-action shotguns
local fake_reload_pump_eject = false -- Eject one round when racking slide (realism)
local fake_reload_ignore_list = true -- Use ignore list for non-immersive fake reloads
local enable_animations = true       -- Master switch for all animations
local check_grenade_mode = false
local display_mode = 0          -- 0: text, 1: numeric, 2: both
local auto_check_reload = false
local color_intensity = 70
local highlight_ammo_mode = 0   -- 0: none, 1: whole message, 2: separate lines
local debug_mode = false

-- Fake reload animation state --
local do_ammo_check_anim = nil  -- nil: not active, 1: started, 2: mutator applied
local wpn_checking = nil        -- Weapon being checked
local det_active = nil          -- Detector that was active before check
local is_fake_reload = false    -- Flag to prevent auto-check duplicate after fake reload

-- Animation timing constants --
local FAKE_RELOAD_MSG_DELAY = 1.5       -- Delay before showing message after fake reload
local BOLT_PUMP_MSG_OFFSET = 0.8        -- Additional delay offset for bolt/pump animations
local AUTO_CHECK_DELAY = 0.15           -- Delay for auto-check after reload
local RESTORE_DET_DELAY = 0.1           -- Delay before checking to restore detector

-- Cached objects (GC optimization) --
local ZERO_VECTOR = vector():set(0, 0, 0)  -- Reusable zero vector for sound positioning

-- Debug mode numpad key mappings --
local numpad_states = {
    [DIK_keys.DIK_NUMPAD0] = 0,
    [DIK_keys.DIK_NUMPAD1] = 1,
    [DIK_keys.DIK_NUMPAD2] = 2,
    [DIK_keys.DIK_NUMPAD3] = 3,
    [DIK_keys.DIK_NUMPAD4] = 4,
    [DIK_keys.DIK_NUMPAD5] = 5,
    [DIK_keys.DIK_NUMPAD6] = 6,
    [DIK_keys.DIK_NUMPAD7] = 7,
    [DIK_keys.DIK_NUMPAD8] = 8,
    [DIK_keys.DIK_NUMPAD9] = 9,
}

-- Caches --
local ammo_type_cache = {}      -- Cache for ammo type classification
local translation_cache = {}    -- Cache for translation strings
local ammo_list_cache = {}      -- Cache for vanilla weapon ammo lists

-- Color definitions --
local function apply_intensity(color, intensity)
    if not color or intensity >= 100 then return color end
    local a = bit.band(bit.rshift(color, 24), 0xFF)
    local r = bit.band(bit.rshift(color, 16), 0xFF)
    local g = bit.band(bit.rshift(color, 8), 0xFF)
    local b = bit.band(color, 0xFF)
    local factor = intensity / 100
    r = math_floor(r * factor)
    g = math_floor(g * factor)
    b = math_floor(b * factor)
    return GetARGB(a, r, g, b)
end

-- Base colors (will be adjusted by intensity)
local base_colors = {
    clr00_Red = GetARGB(0xff, 0xff, 0x00, 0x00),
    clr01_RedOrange = GetARGB(0xff, 0xff, 0x40, 0x00),
    clr02_Orange = GetARGB(0xff, 0xff, 0x80, 0x00),
    clr03_Amber = GetARGB(0xff, 0xff, 0xc0, 0x00),
    clr04_LemonGlacier = GetARGB(0xff, 0xff, 0xff, 0x00),
    clr05_LaserLemon = GetARGB(0xff, 0xff, 0xff, 0x80),
    clr06_White = GetARGB(0xff, 0xff, 0xff, 0xff),
}

-- Active colors (adjusted by intensity setting)
local clr00_Red = base_colors.clr00_Red
local clr01_RedOrange = base_colors.clr01_RedOrange
local clr02_Orange = base_colors.clr02_Orange
local clr03_Amber = base_colors.clr03_Amber
local clr04_LemonGlacier = base_colors.clr04_LemonGlacier
local clr05_LaserLemon = base_colors.clr05_LaserLemon
local clr06_White = base_colors.clr06_White
local clrEE_Purple = utils_xml.get_color("d_purple", true)

-- Base ammo type colors (will be adjusted by intensity)
local base_ammo_type_colors = {
    ap = GetARGB(0xff, 0x80, 0xc0, 0xff),       -- Light blue
    hp = GetARGB(0xff, 0xff, 0xc0, 0x80),       -- Light orange
    fmj = GetARGB(0xff, 0x80, 0xff, 0x80),      -- Light green
    tracer = GetARGB(0xff, 0xff, 0xff, 0x80),   -- Light yellow
    fire = GetARGB(0xff, 0xff, 0x80, 0x40),     -- Orange-red
    sub = GetARGB(0xff, 0xa0, 0xa0, 0xff),      -- Light purple
    enhanced = GetARGB(0xff, 0xc0, 0xff, 0xc0), -- Pale green
    slug = GetARGB(0xff, 0xc0, 0xc0, 0xc0),     -- Silver
    buck = GetARGB(0xff, 0xff, 0xa0, 0xa0),     -- Light pink
}

-- Active ammo type colors (adjusted by intensity setting)
local ammo_type_colors = {
    ap = base_ammo_type_colors.ap,
    hp = base_ammo_type_colors.hp,
    fmj = base_ammo_type_colors.fmj,
    tracer = base_ammo_type_colors.tracer,
    fire = base_ammo_type_colors.fire,
    sub = base_ammo_type_colors.sub,
    enhanced = base_ammo_type_colors.enhanced,
    slug = base_ammo_type_colors.slug,
    buck = base_ammo_type_colors.buck,
}

-- Messages table (rebuilt when colors change)
local messages = {}

-- Must be defined before update_colors since it's called from there
local function rebuild_messages()
    messages = {
        { m = "st_ac_near_empty", c = clr00_Red },         -- <1/10
        { m = "st_ac_near_empty", c = clr01_RedOrange },   -- <2/10
        { m = "st_ac_less_half", c = clr01_RedOrange },    -- <3/10
        { m = "st_ac_less_half", c = clr02_Orange },       -- <4/10
        { m = "st_ac_about_half", c = clr02_Orange },      -- <5/10
        { m = "st_ac_about_half", c = clr03_Amber },       -- <6/10
        { m = "st_ac_more_half", c = clr03_Amber },        -- <7/10
        { m = "st_ac_more_half", c = clr04_LemonGlacier }, -- <8/10
        { m = "st_ac_nearly_full", c = clr04_LemonGlacier }, -- <9/10
        { m = "st_ac_nearly_full", c = clr05_LaserLemon }, -- <10/10
        { m = "st_ac_full", c = clr06_White }              -- full
    }
end
rebuild_messages() -- Initialize

local function update_colors()
    clr00_Red = apply_intensity(base_colors.clr00_Red, color_intensity)
    clr01_RedOrange = apply_intensity(base_colors.clr01_RedOrange, color_intensity)
    clr02_Orange = apply_intensity(base_colors.clr02_Orange, color_intensity)
    clr03_Amber = apply_intensity(base_colors.clr03_Amber, color_intensity)
    clr04_LemonGlacier = apply_intensity(base_colors.clr04_LemonGlacier, color_intensity)
    clr05_LaserLemon = apply_intensity(base_colors.clr05_LaserLemon, color_intensity)
    clr06_White = apply_intensity(base_colors.clr06_White, color_intensity)
    -- Rebuild messages table with new colors
    rebuild_messages()
    
    -- Update ammo type colors with intensity
    ammo_type_colors.ap = apply_intensity(base_ammo_type_colors.ap, color_intensity)
    ammo_type_colors.hp = apply_intensity(base_ammo_type_colors.hp, color_intensity)
    ammo_type_colors.fmj = apply_intensity(base_ammo_type_colors.fmj, color_intensity)
    ammo_type_colors.tracer = apply_intensity(base_ammo_type_colors.tracer, color_intensity)
    ammo_type_colors.fire = apply_intensity(base_ammo_type_colors.fire, color_intensity)
    ammo_type_colors.sub = apply_intensity(base_ammo_type_colors.sub, color_intensity)
    ammo_type_colors.enhanced = apply_intensity(base_ammo_type_colors.enhanced, color_intensity)
    ammo_type_colors.slug = apply_intensity(base_ammo_type_colors.slug, color_intensity)
    ammo_type_colors.buck = apply_intensity(base_ammo_type_colors.buck, color_intensity)
    print_dbg("update_colors: intensity=%s, ap_color=%s", tostring(color_intensity), tostring(ammo_type_colors.ap))
end

-- Cached translation lookup --
local function get_translation(key)
    local cached = translation_cache[key]
    if cached then return cached end
    
    local translated = gc(key)
    translation_cache[key] = translated
    return translated
end

-- Debug logging --
local dbg_log
function print_dbg(msg, ...)
    if not debug_mode then
        if not mcm_log then
            return
        elseif not ui_mcm or not ui_mcm.MCM_DEBUG then
            return
        end
    end
    
    if not mcm_log then
        printf("![AC] " .. msg, ...)
    else
        if not dbg_log then
            dbg_log = mcm_log.new("![AC]")
            dbg_log.enabled = true
        end
        if dbg_log then dbg_log:log(msg, ...) end
    end
end

-- Utility functions --
function null_function()
    return false
end

-- Separate nil-returning function for get_sec_chambered
local function nil_function()
    return nil
end

local function l_round(value)
    return math_floor(value + 0.5)
end

local function clamp(val, min_val, max_val)
    return math_min(math_max(val, min_val), max_val)
end

-- MagsRedux compatibility shim --
function get_mag_loaded_shim(id)
    give_news(get_translation("st_ac_magsredux_update") or "You are using an older version of MagsRedux. Update to Github version for best experience.")
    local mag_data = get_data(id)
    return (mag_data and mag_data.section ~= "no_mag") and mag_data or nil
end

-- MagsRedux function references (set in on_game_start) --
get_data = null_function
set_data = null_function
get_mag_loaded = null_function
is_supported_weapon = null_function
is_jammed_weapon = null_function
get_sec_chambered = nil_function  -- Must return nil, not false

-- Get current ammo section for vanilla (non-MagsRedux) weapons --
-- Uses caching to avoid repeated str_explode calls (GC optimization)
local function get_vanilla_ammo_section(weapon)
    if not weapon then return nil end
    local sec = weapon:section()
    
    -- Check cache first
    local cached_list = ammo_list_cache[sec]
    if cached_list == false then return nil end  -- Cached "no ammo class"
    
    if not cached_list then
        local ammo_class = SYS_GetParam(0, sec, "ammo_class")
        if not ammo_class then 
            ammo_list_cache[sec] = false
            return nil 
        end
        cached_list = str_explode(ammo_class, ",")
        if not cached_list or #cached_list == 0 then
            ammo_list_cache[sec] = false
            return nil
        end
        ammo_list_cache[sec] = cached_list
    end
    
    -- Get current ammo type index (0-based) and return section
    local ammo_type_idx = weapon:get_ammo_type()
    return cached_list[ammo_type_idx + 1]
end

-- Keybind system --
local mcm_keybinds = ui_mcm and ui_mcm.key_hold
local modifier = 0
local mode = 0

local modes = {
    [0] = { 
        ["call"] = { "on_key_press", "on_key_hold" }, 
        ["function"] = function(key) ui_mcm.simple_press("rax_ammo_check", key, check_Ammo) end 
    },
    [1] = { 
        ["call"] = { "on_key_press", "on_key_hold" }, 
        ["function"] = function(key) if ui_mcm.double_tap("rax_ammo_check", key) then check_Ammo() end end 
    },
    [2] = { 
        ["call"] = { "on_key_hold", "on_key_press" }, 
        ["function"] = function(key) if ui_mcm.key_hold("rax_ammo_check", key) then check_Ammo() end end 
    }
}

local direction_keys = {
    [key_bindings.kFWD] = true,
    [key_bindings.kBACK] = true,
    [key_bindings.kL_STRAFE] = true,
    [key_bindings.kACCEL] = true,
    [key_bindings.kR_STRAFE] = true
}

local weapon_hidden = false

function on_key_press(key)
    local bind = dik_to_bind(key)
    if weapon_hidden and not direction_keys[bind] then
        weapon_hidden = false
    end

    -- Debug mode: Numpad keys 0-9 test weapon states
    if debug_mode then
        if numpad_states[key] then
            debug_test_state(numpad_states[key])
            return
        end
        
        -- Numpad * lists animations
        if key == DIK_keys.DIK_MULTIPLY then
            debug_list_animations()
            return
        end
        
        -- Numpad + increases animation delay
        if key == DIK_keys.DIK_ADD then
            debug_adjust_delay(0.1)
            return
        end
        
        -- Numpad - decreases animation delay
        if key == DIK_keys.DIK_SUBTRACT then
            debug_adjust_delay(-0.1)
            return
        end
    end

    if key ~= mcm_key then return end
    if not mcm_keybinds then
        check_Ammo()
        return
    end
    if ui_mcm.get_mod_key(modifier) then
        modes[mode]["function"](key)
    end
end

function on_key_hold(key)
    if key ~= mcm_key then return end
    if ui_mcm.get_mod_key(modifier) then
        modes[mode]["function"](key)
    end
end

-- Message display --
local function display_message(message, clr)
    if not message then return false end
    actor_menu.set_msg(1, message, msg_duration, clr)
    return true
end

-- Ammo type classification (with caching) --
-- Returns: type_key, display_tag
local function classify_ammo_type(section)
    if not section then return "unknown", nil end
    
    -- Check cache first
    local cached = ammo_type_cache[section]
    if cached then
        return cached.type, cached.tag
    end
    
    local sec_lower = string_lower(section)
    local result_type = "unknown"
    local result_tag = nil
    
    -- AP (Armor Piercing): ap, pp, pbp, bp, 7h14, 7n, sp10, ss190, dart, barrikada
    if string_find(sec_lower, "_ap") 
       or string_find(sec_lower, "_bp") 
       or string_find(sec_lower, "_pbp")
       or string_find(sec_lower, "_pp")
       or string_find(sec_lower, "7h14")
       or string_find(sec_lower, "7n")
       or string_find(sec_lower, "sp10")
       or string_find(sec_lower, "ss190")
       or string_find(sec_lower, "_dart")
       or string_find(sec_lower, "barrikada") then
        result_type, result_tag = "ap", "(AP)"
    
    -- HP (Hollow Point): hp, jhp, hydro, sp (soft point)
    elseif string_find(sec_lower, "_hp") 
       or string_find(sec_lower, "jhp")
       or string_find(sec_lower, "hydro")
       or string_find(sec_lower, "_sp_") then
        result_type, result_tag = "hp", "(HP)"
    
    -- Tracer
    elseif string_find(sec_lower, "_t_") 
       or string_find(sec_lower, "_tracer") then
        result_type, result_tag = "tracer", "(T)"
    
    -- Incendiary/Fire: fire, zp
    elseif string_find(sec_lower, "fire") 
       or string_find(sec_lower, "_zp") then
        result_type, result_tag = "fire", "(I)"
    
    -- Subsonic
    elseif string_find(sec_lower, "sub") then
        result_type, result_tag = "sub", "(SUB)"
    
    -- Match/Enhanced: ep, pmm, pab9, 7h1
    elseif string_find(sec_lower, "_ep")
       or string_find(sec_lower, "_pmm")
       or string_find(sec_lower, "pab9")
       or string_find(sec_lower, "7h1") then
        result_type, result_tag = "enhanced", "(+)"
    
    -- Slug (shotgun): slug, zhekan, shrapnel, eco
    elseif string_find(sec_lower, "slug")
       or string_find(sec_lower, "zhekan") 
       or string_find(sec_lower, "shrapnel")
       or string_find(sec_lower, "_eco") then
        result_type, result_tag = "slug", "(SL)"
    
    -- Buckshot: buck, shot (but not shrapnel which is slug)
    elseif string_find(sec_lower, "buck") 
       or (string_find(sec_lower, "_shot") and not string_find(sec_lower, "shrapnel")) then
        result_type, result_tag = "buck", "(BK)"
    
    -- FMJ/Ball/Standard: fmj, ball, ps, p, ss195
    elseif string_find(sec_lower, "_fmj") 
       or string_find(sec_lower, "_ball")
       or string_find(sec_lower, "_ps")
       or string_match(sec_lower, "_p$")
       or string_find(sec_lower, "ss195") then
        result_type, result_tag = "fmj", "(FMJ)"
    end
    
    -- Store in cache
    ammo_type_cache[section] = { type = result_type, tag = result_tag }
    return result_type, result_tag
end

-- Get color for ammo type (used when highlight is enabled) --
local function get_ammo_type_color(ammo_type)
    return ammo_type_colors[ammo_type]
end

-- Remove duplicate suffix from ammo name if it matches the tag content --
-- e.g., "9x19 HP" + "(HP)" ? "9x19"
local function remove_duplicate_suffix(ammo_name, tag)
    if not ammo_name or not tag then return ammo_name end
    
    -- Extract tag content without parentheses (e.g., "HP" from "(HP)")
    local tag_content = string_match(tag, "%((.+)%)")
    if not tag_content then return ammo_name end
    
    local name_len = #ammo_name
    local tag_len = #tag_content
    
    -- Need at least space + tag length
    if name_len < tag_len + 1 then return ammo_name end
    
    -- Check if ends with " TAG" (case-insensitive)
    local suffix_start = name_len - tag_len
    local potential_suffix = string_sub(ammo_name, suffix_start + 1)
    local char_before = string_sub(ammo_name, suffix_start, suffix_start)
    
    if char_before == " " and string_lower(potential_suffix) == string_lower(tag_content) then
        return string_sub(ammo_name, 1, suffix_start - 1)
    end
    
    return ammo_name
end

-- Classify ammo type based on display name (more reliable than section) --
-- Returns: type_key, display_tag
local function classify_ammo_by_name(ammo_name)
    if not ammo_name or ammo_name == "" then return "unknown", nil end
    
    local name_lower = string_lower(ammo_name)
    
    -- HP variants (check early - common suffix)
    if string_match(name_lower, " hp$") or string_match(name_lower, "hp$")
       or string_find(name_lower, "jhp") or string_find(name_lower, "hydro") then
        return "hp", "(HP)"
    end
    
    -- AP variants (check after HP to avoid false positives)
    if string_match(name_lower, " ap$") or string_match(name_lower, "ap$")
       or string_match(name_lower, " bp$") or string_match(name_lower, "bp$")
       or string_match(name_lower, " pbp$") or string_find(name_lower, " pp")
       or string_find(name_lower, "sp10") or string_find(name_lower, "ss190") then
        return "ap", "(AP)"
    end
    
    -- 7N series (Russian AP designations - check separately)
    if string_find(name_lower, "7n") then
        return "ap", "(AP)"
    end
    
    -- Tracer
    if string_find(name_lower, "tracer") or string_match(name_lower, " t$") then
        return "tracer", "(T)"
    end
    
    -- Incendiary
    if string_find(name_lower, "fire") or string_find(name_lower, "incend")
       or string_find(name_lower, " zp") then
        return "fire", "(I)"
    end
    
    -- Subsonic
    if string_find(name_lower, "sub") then
        return "sub", "(SUB)"
    end
    
    -- Enhanced
    if string_match(name_lower, " ep$") or string_find(name_lower, "pmm")
       or string_find(name_lower, "match") then
        return "enhanced", "(+)"
    end
    
    -- Slug
    if string_find(name_lower, "slug") or string_find(name_lower, "zhekan")
       or string_find(name_lower, "shrapnel") or string_find(name_lower, "eco") then
        return "slug", "(SL)"
    end
    
    -- Buckshot
    if string_find(name_lower, "buck") or string_find(name_lower, "shot") then
        return "buck", "(BK)"
    end
    
    -- FMJ/Standard
    if string_find(name_lower, "fmj") or string_find(name_lower, "ball")
       or string_match(name_lower, " ps$") or string_match(name_lower, " p$") then
        return "fmj", "(FMJ)"
    end
    
    return "unknown", nil
end

-- Format ammo type string for display --
-- display_round: ammo section for name display (chambered round)
-- tag_round: ammo section for tag classification (magazine contents)
-- Returns: formatted_string, ammo_type_key, tag_for_separate_line
-- Format ammo type string for display --
-- display_round: ammo section for name display (chambered round)
-- tag_round: ammo section for tag classification (magazine contents)
-- Returns: formatted_string, ammo_type_key, tag_for_separate_line
local function format_ammo_type_string(display_round, tag_round)
    if not display_round and not tag_round then return "", nil, nil end
    
    local result = ""
    local separate_tag = nil
    local ammo_type = nil
    local tag = nil
    
    -- Always get ammo name for tag classification
    -- Prefer tag_round (magazine contents) for consistent classification
    local round_for_tag = tag_round or display_round
    local ammo_name_for_tag = nil
    if round_for_tag then
        ammo_name_for_tag = gc(ui_item.get_sec_short_name(round_for_tag))
        if ammo_name_for_tag == "" then
            ammo_name_for_tag = nil
        end
    end
    
    -- Get tag from ammo name (more reliable than section)
    if ammo_name_for_tag then
        ammo_type, tag = classify_ammo_by_name(ammo_name_for_tag)
    end
    
    -- If no tag from name, try section-based classification as fallback
    if not tag and round_for_tag then
        ammo_type, tag = classify_ammo_type(round_for_tag)
    end
    
    -- Get display name only if show_ammo_type is enabled (use same round for consistency)
    local ammo_name_display = nil
    if show_ammo_type and ammo_name_for_tag then
        ammo_name_display = ammo_name_for_tag
    end
    
    -- Remove duplicate suffix if both ammo type and tag are shown
    if ammo_name_display and show_ammo_tag and tag then
        ammo_name_display = remove_duplicate_suffix(ammo_name_display, tag)
    end
    
    -- Determine what to show and how to highlight
    if show_ammo_tag and tag then
        -- Tag is enabled - highlight applies to tag
        if highlight_ammo_mode == 2 then
            -- Separate lines: ammo name on line 1, tag on line 2
            result = ammo_name_display or ""
            separate_tag = tag
        else
            -- None or Whole: everything on one line
            if ammo_name_display then
                result = ammo_name_display .. " " .. tag
            else
                result = tag
            end
        end
    elseif show_ammo_type and ammo_name_display then
        -- Tag disabled but ammo type enabled - highlight applies to ammo type name
        if highlight_ammo_mode == 2 then
            -- Separate lines: nothing on line 1, ammo name on line 2 with color
            result = ""
            separate_tag = ammo_name_display
        else
            -- None or Whole: ammo name on line 1
            result = ammo_name_display
        end
    end
    
    return result, ammo_type, separate_tag
end

-- Format ammo display based on display_mode --
-- display_round: for ammo type name (chambered round)
-- tag_round: for ammo tag classification (magazine contents)
-- Returns: message, ammo_type_key, tag_for_separate_line
local function format_ammo_message(text_msg, current, max, display_round, tag_round)
    local result
    
    if display_mode == 0 then
        -- Text only
        result = get_translation(text_msg)
    elseif display_mode == 1 then
        -- Numeric only
        result = string_format("%d/%d", current, max)
    else
        -- Both
        result = string_format("%s (%d/%d)", get_translation(text_msg), current, max)
    end
    
    local ammo_type = nil
    local separate_tag = nil
    
    -- Append ammo info if enabled and we have ammo
    if (show_ammo_type or show_ammo_tag) and (display_round or tag_round) then
        local ammo_str, atype, tag = format_ammo_type_string(display_round, tag_round)
        ammo_type = atype
        separate_tag = tag
        if ammo_str and ammo_str ~= "" then
            -- Use comma only when ammo type name is shown
            local separator = show_ammo_type and ", " or " "
            result = result .. separator .. ammo_str
        end
    end
    
    return result, ammo_type, separate_tag
end

-- Shared ammo status calculation --
-- Returns: message, color, ammo_type, separate_tag
local function get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    local message = ""
    local clr = nil
    local ammo_type = nil
    local separate_tag = nil
    
    local mag_data = get_mag_loaded(weaponId)
    local is_supported = is_supported_weapon(sec)
    
    -- Determine weapon status and message
    if is_jammed_weapon(weapon) then
        message = get_translation("st_ac_jammed")
        clr = use_clr and clr00_Red or clr06_White
        
    elseif in_grenade_mode then
        message = currentAmmo == 1 and get_translation("st_ac_grenade") or get_translation("st_ac_empty")
        clr = use_clr and (currentAmmo == 1 and clr06_White or clr00_Red) or clr06_White
        
    elseif currentAmmo == 0 then
        if is_supported and not mag_data then
            message = get_translation("st_ac_noMag")
        else
            message = get_translation("st_ac_empty")
        end
        clr = use_clr and clr00_Red or clr06_White
        
    else
        local display_round = nil  -- For ammo type name
        local tag_round = nil      -- For ammo tag
        local max_ammo = 0
        local base_mag_size = SYS_GetParam(2, sec, "ammo_mag_size", 0)
        local is_chamber_only = false  -- Track if only chambered round remains
        local has_empty_mag = false    -- Track if magazine is inserted but empty

        if not mag_data and is_supported then
            -- No magazine inserted, one in the chamber
            currentAmmo = 1
            max_ammo = 10
            is_chamber_only = true
            has_empty_mag = false
        elseif is_supported and mag_data then
            print_dbg("Checking magazine section: %s", mag_data.section)
            max_ammo = SYS_GetParam(2, mag_data.section, "max_mag_size") or 1
            
            if magazines_mcm and magazines_mcm.get_config("retain_round") then
                -- With retain_round: last in array is chambered, second-to-last is magazine top
                local mag_top = mag_data.loaded[#mag_data.loaded - 1]
                if mag_top then
                    display_round = mag_top
                    tag_round = mag_top
                else
                    -- Only chambered round left, magazine is empty
                    is_chamber_only = true
                    has_empty_mag = true
                end
            else
                -- Without retain_round: top of stack is what we'll fire next
                -- Check if stack module exists (MagsRedux dependency)
                if stack and stack.peek then
                    display_round = stack.peek(mag_data.loaded)
                elseif mag_data.loaded and #mag_data.loaded > 0 then
                    -- Fallback: get last element directly
                    display_round = mag_data.loaded[#mag_data.loaded]
                end
                tag_round = display_round
            end
        else
            -- Non-MagsRedux weapon: get ammo section from weapon's ammo_class list
            display_round = get_sec_chambered(weapon)
            -- Fallback to vanilla method if MagsRedux function returned nil
            if not display_round then
                display_round = get_vanilla_ammo_section(weapon)
            end
            tag_round = display_round
            max_ammo = base_mag_size
        end

        -- Guard against division by zero
        if not max_ammo or max_ammo <= 0 then max_ammo = 1 end
        
        local curAmmoPerc = currentAmmo / max_ammo

        if currentAmmo == max_ammo + 1 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_plus1", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clr06_White or clr06_White
            
        elseif curAmmoPerc > 1 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_overfull", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clrEE_Purple or clr06_White
            
        elseif currentAmmo == 1 and base_mag_size == 2 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_just_one", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clr03_Amber or clr06_White
            
        elseif is_chamber_only then
            -- Chamber only - don't show ammo type/tag
            if has_empty_mag then
                message = get_translation("st_ac_empty_mag_oitc")
            else
                message = get_translation("st_ac_no_mag_oitc")
            end
            clr = use_clr and clr00_Red or clr06_White
            
        else
            -- Calculate index based on percentage
            -- Use ceil so 20% maps to index 2 (near_empty), not index 3 (less_half)
            local idx
            if currentAmmo == max_ammo then
                idx = #messages -- Full
            else
                idx = clamp(math_ceil(curAmmoPerc * 10), 1, #messages - 1)
            end
            print_dbg("Ammo index: %s (%.1f%%, %d/%d)", idx, curAmmoPerc * 100, currentAmmo, max_ammo)
            
            message, ammo_type, separate_tag = format_ammo_message(messages[idx].m, currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and messages[idx].c or clr06_White
            print_dbg("Color: use_clr=%s, idx=%s, clr=%s", tostring(use_clr), idx, tostring(clr))
        end
        
        -- Apply ammo type color based on highlight mode
        -- Only apply when Colored Messages is enabled
        if use_clr and ammo_type and highlight_ammo_mode == 1 then
            local ammo_clr = get_ammo_type_color(ammo_type)
            print_dbg("Highlight override: mode=%s, ammo_type=%s, ammo_clr=%s", highlight_ammo_mode, ammo_type, tostring(ammo_clr))
            if ammo_clr then
                clr = ammo_clr
            end
        end
    end
    
    return message, clr, ammo_type, separate_tag
end

-- Display ammo status with optional second line --
local function display_ammo_status(message, clr, ammo_type, separate_tag)
    display_message(message, clr)
    
    -- Display separate tag line if mode 2
    if highlight_ammo_mode == 2 and separate_tag then
        local tag_clr = use_clr and get_ammo_type_color(ammo_type) or clr06_White
        actor_menu.set_msg(2, separate_tag, msg_duration, tag_clr)
    end
end

-- Auto-check after reload - triggered when HUD animation ends --
local pending_reload_check = false

-- Pre-defined callback for auto-check after reload (GC optimization)
local function auto_check_after_reload_callback()
    local actor = db.actor
    if not actor then return true end
    
    local weapon = actor:active_item()
    if not weapon or not IsWeapon(weapon) then return true end
    
    -- Build and display message directly (no weapon hide animation)
    check_Ammo_silent()
    return true
end

-- Callback for HUD animation end - optimized to avoid GC pressure
-- Uses case-insensitive pattern matching instead of string_lower
function actor_on_hud_animation_end(item, section, motion, state, slot)
    if not auto_check_reload then return end
    if not motion then return end
    if not item then return end
    if not IsWeapon(item) then return end
    
    -- Skip if this was a fake reload (we already displayed the message)
    if is_fake_reload then
        print_dbg("Skipping auto-check: was fake reload")
        is_fake_reload = false
        return
    end
    
    -- Use case-insensitive pattern matching (avoids creating new string)
    -- Check reload first (most common case)
    if string_find(motion, "[Rr]eload") then
        pending_reload_check = false
        print_dbg("Reload animation ended: %s", motion)
        CreateTimeEvent("ammo_check", "auto_check", AUTO_CHECK_DELAY, auto_check_after_reload_callback)
        return
    end
    
    -- Check for shotgun open animation
    if string_find(motion, "[Oo]pen") and string_find(motion, "anm") then
        pending_reload_check = true
        print_dbg("Shotgun reload started: %s", motion)
        return
    end
    
    -- Check for shotgun close animation (only if we're tracking a reload)
    if pending_reload_check and string_find(motion, "[Cc]lose") then
        pending_reload_check = false
        print_dbg("Shotgun reload ended: %s", motion)
        CreateTimeEvent("ammo_check", "auto_check", AUTO_CHECK_DELAY, auto_check_after_reload_callback)
    end
end

function actor_on_weapon_jammed(weapon)
    print_dbg("Weapon jammed")
end

-- ============================================
-- Animation Mutator for Fake Reload Mode
-- ============================================

-- Check if weapon has a specific HUD animation --
local function has_animation(section, anm)
    local hud_section = SYS_GetParam(0, section, "hud") or section
    return SYS_GetParam(0, hud_section, anm)
end

-- Animation mutator for fake reload - intercepts inspect animation --
local function mag_check_animation(anm_table, obj)
    -- Handle end of ammo check animation
    if wpn_checking and obj and wpn_checking:id() == obj:id() and do_ammo_check_anim == 2 then
        wpn_checking = nil
        do_ammo_check_anim = nil
        
        if det_active then
            db.actor:show_detector(true)
        end
        det_active = nil
    end
    
    -- Handle start of ammo check animation (state 4 = inspect/bore)
    if do_ammo_check_anim == 1 and obj and obj:get_state() == 4 then
        wpn_checking = obj
        local sec = obj:section()
        
        local is_supported = is_supported_weapon(sec)
        local has_mag_data = get_mag_loaded(obj:id())
        
        -- Try different ammo check animations
        -- If none exist, DON'T change the animation - let the default anm_bore play
        if animation_common and animation_common.has_animation then
            if is_supported and not has_mag_data and animation_common.has_animation(sec, "anm_ammo_check_no_mag") then
                anm_table.anm_name = "anm_ammo_check_no_mag"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            elseif obj:get_ammo_in_magazine() == 0 and animation_common.has_animation(sec, "anm_ammo_check_empty") then
                anm_table.anm_name = "anm_ammo_check_empty"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            elseif animation_common.has_animation(sec, "anm_ammo_check") then
                anm_table.anm_name = "anm_ammo_check"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            else
                -- No ammo_check animation - let the default inspect animation play
                print_dbg("No ammo_check animation for %s, using default inspect: %s", sec, anm_table.anm_name)
            end
        end
        
        do_ammo_check_anim = 2
    end
end

-- Game initialization --
function on_game_start()
    -- Setup MagsRedux integration
    if magazine_binder then
        get_data = magazine_binder.get_data
        set_data = magazine_binder.set_data
        get_mag_loaded = magazine_binder.get_mag_loaded or get_mag_loaded_shim
        is_supported_weapon = magazine_binder.is_supported_weapon
        is_jammed_weapon = magazines.is_jammed_weapon
        get_sec_chambered = magazines.get_sec_chambered
        print_dbg("MagsRedux installed. Working in integrated mode.")
    else
        get_data = null_function
        set_data = null_function
        is_supported_weapon = null_function
        get_mag_loaded = null_function
        is_jammed_weapon = null_function
        get_sec_chambered = nil_function  -- Must return nil, not false
        print_dbg("MagsRedux not found. Working in standalone mode.")
    end

    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("actor_on_hud_animation_end", actor_on_hud_animation_end)
    RegisterScriptCallback("actor_on_weapon_jammed", actor_on_weapon_jammed)
    
    -- Register animation mutator for fake reload mode
    if animation_common and animation_common.add_anim_mutator then
        animation_common.add_anim_mutator(mag_check_animation, 2)
        print_dbg("Animation mutator registered: mag_check_animation (priority 2)")
    end
end

-- ============================================
-- Animation Debug System
-- When Debug Mode is ON:
--   Numpad 0-9 = Test weapon state 0-9
--   Numpad * = List all animations for current weapon
--   Numpad + = Increase bolt/pump animation delay (+0.1s)
--   Numpad - = Decrease bolt/pump animation delay (-0.1s)
-- ============================================

-- Debug: Test different weapon states
function debug_test_state(state_num)
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    local current_state = weapon:get_state()
    
    -- Only switch if weapon is idle
    if current_state ~= 0 then
        db.actor:give_game_news("AmmoCheck Debug", "Weapon not idle! State: " .. current_state, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    db.actor:give_game_news("AmmoCheck Debug", "Testing state " .. state_num .. " on " .. sec, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
    weapon:switch_state(state_num)
end

-- Debug: List all animations for current weapon
function debug_list_animations()
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    local hud_section = ini_sys:r_string_ex(sec, "hud") or sec
    
    local animations_to_check = {
        "anm_idle", "anm_reload", "anm_reload_empty",
        "anm_open", "anm_close", "anm_add_cartridge",
        "anm_bore", "anm_shots", "anm_shoot",
        "anm_ammo_check", "anm_ammo_check_empty", "anm_ammo_check_no_mag",
    }
    
    local found = {}
    for _, anm in ipairs(animations_to_check) do
        local value = SYS_GetParam(0, hud_section, anm)
        if value then
            table.insert(found, anm)
        end
    end
    
    local msg = sec .. ":\\n" .. table.concat(found, ", ")
    db.actor:give_game_news("AmmoCheck Debug - Animations", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 8000, 0)
    
    -- Also print to console for full details
    printf("[AmmoCheck DEBUG] Weapon: %s | HUD: %s", sec, hud_section)
    for _, anm in ipairs(found) do
        printf("  [+] %s", anm)
    end
end

-- Debug: Adjust animation delay for bolt/pump weapons
function debug_adjust_delay(delta)
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    
    if not ammo_check_weapons then
        db.actor:give_game_news("AmmoCheck Debug", "Weapons config not loaded!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    if not ammo_check_weapons.adjust_delay then
        db.actor:give_game_news("AmmoCheck Debug", "adjust_delay not available!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local new_delay, weapon_type = ammo_check_weapons.adjust_delay(sec, delta)
    
    if new_delay then
        local type_name = weapon_type == "bolt" and "Bolt-action" or "Pump-action"
        local msg = string.format("%s delay: %.1fs", type_name, new_delay)
        db.actor:give_game_news("AmmoCheck Debug", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 2000, 0)
        printf("[AmmoCheck DEBUG] %s %s delay set to %.1fs", sec, weapon_type, new_delay)
    else
        db.actor:give_game_news("AmmoCheck Debug", "Weapon not in bolt/pump lists: " .. sec, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
    end
end

-- MCM Configuration --
function on_mcm_load()
    return {
        id = "rax_ammo_check",
        sh = true,
        gr = {
            -- Header
            { id = "ammo_check", type = "slide", link = "ui_options_slider_player", text = "ui_mm_title_rax_ammo_check", size = { 512, 50 }, spacing = 20 },
            
            -- Display Settings
            { id = "divider_display", type = "line" },
            { id = "title_display", type = "title", text = "ui_mcm_rax_ammo_check_title_display" },
            { id = "usecolor", type = "check", val = 1, def = true },
            { id = "color_intensity", type = "track", val = 2, min = 30, max = 100, step = 10, def = 70 },
            { id = "display_mode", type = "list", val = 2, def = 0, 
                content = { 
                    { 0, "dm_text" }, 
                    { 1, "dm_numeric" }, 
                    { 2, "dm_both" } 
                } 
            },
            { id = "show_ammo_type", type = "check", val = 1, def = false },
            { id = "show_ammo_tag", type = "check", val = 1, def = true },
            { id = "highlight_ammo_mode", type = "list", val = 2, def = 0,
                content = {
                    { 0, "ham_none" },
                    { 1, "ham_whole" },
                    { 2, "ham_separate" }
                }
            },
            { id = "msg_duration", type = "track", val = 2, min = 1, max = 5, step = 0.5, def = 2 },
            
            -- HUD Settings
            { id = "divider_hud", type = "line" },
            { id = "title_hud", type = "title", text = "ui_mcm_rax_ammo_check_title_hud" },
            { id = "hidecounter", type = "check", val = 1, def = true },
            { id = "hideicon", type = "check", val = 1, def = true },
            
            -- Behavior Settings
            { id = "divider_behavior", type = "line" },
            { id = "title_behavior", type = "title", text = "ui_mcm_rax_ammo_check_title_behavior" },
            { id = "check_grenade_mode", type = "check", val = 1, def = false },
            { id = "auto_check_reload", type = "check", val = 1, def = false },
            
            -- Animation Settings
            { id = "divider_anim", type = "line" },
            { id = "title_anim", type = "title", text = "ui_mcm_rax_ammo_check_title_anim" },
            { id = "enable_animations", type = "check", val = 1, def = true },
            { id = "anim_mode", type = "list", val = 2, def = 2,
                content = {
                    { 0, "anim_mode_default" },
                    { 1, "anim_mode_lower" },
                    { 2, "anim_mode_fake_reload" }
                }
            },
            { id = "no_magazine_fallback", type = "list", val = 2, def = 1,
                content = {
                    { 0, "fallback_hide_show" },
                    { 1, "fallback_lower" },
                    { 2, "fallback_none" }
                }
            },
            { id = "fake_reload_fallback", type = "list", val = 2, def = 1,
                content = {
                    { 0, "fallback_hide_show" },
                    { 1, "fallback_lower" }
                }
            },
            { id = "fake_reload_bolt_cycle", type = "check", val = 1, def = true },
            { id = "fake_reload_bolt_eject", type = "check", val = 1, def = false },
            { id = "fake_reload_pump_rack", type = "check", val = 1, def = true },
            { id = "fake_reload_pump_eject", type = "check", val = 1, def = false },
            { id = "fake_reload_ignore_list", type = "check", val = 1, def = true },
            { id = "busy_hands_delay", type = "track", val = 2, min = 0.5, max = 3, step = 0.25, def = 1 },
            
            -- Keybind Settings
            { id = "divider_keys", type = "line" },
            { id = "title_keys", type = "title", text = "ui_mcm_rax_ammo_check_title_keys" },
            { id = "keybind", type = "key_bind", val = 2, def = DIK_keys.DIK_F },
            { id = "modifier", type = ui_mcm.kb_mod_radio, val = 2, def = 0, hint = "mcm_kb_modifier", 
                content = { { 0, "mcm_kb_mod_none" }, { 1, "mcm_kb_mod_shift" }, { 3, "mcm_kb_mod_alt" } } 
            },
            { id = "mode", type = ui_mcm.kb_mod_radio, val = 2, def = 2, hint = "mcm_kb_mode", 
                content = { { 0, "mcm_kb_mode_press" }, { 1, "mcm_kb_mode_dtap" }, { 2, "mcm_kb_mode_hold" } } 
            },
            { id = "desc_mcm", type = "desc", text = "ui_mcm_rax_ammo_check_update_mcm", clr = { 255, 175, 0, 0 }, 
                precondition = { function() return not mcm_keybinds end } 
            },
            
            -- Debug Settings
            { id = "divider_debug", type = "line" },
            { id = "title_debug", type = "title", text = "ui_mcm_rax_ammo_check_title_debug" },
            { id = "debug_mode", type = "check", val = 1, def = false },
        }
    }
end

function actor_on_first_update()
    on_option_change()
end

function on_option_change()
    -- Clear caches when settings change
    ammo_type_cache = {}
    translation_cache = {}
    
    if ui_mcm then
        -- Display settings
        local clr_val = ui_mcm.get("rax_ammo_check/usecolor")
        -- MCM might return true/false, 1/0, or nil
        use_clr = (clr_val == true or clr_val == 1)
        color_intensity = ui_mcm.get("rax_ammo_check/color_intensity") or 100
        update_colors() -- Apply color intensity changes
        print_dbg("Settings loaded: use_clr=%s (raw=%s), color_intensity=%s", tostring(use_clr), tostring(clr_val), tostring(color_intensity))
        display_mode = ui_mcm.get("rax_ammo_check/display_mode") or 0
        show_ammo_type = ui_mcm.get("rax_ammo_check/show_ammo_type")
        if show_ammo_type == nil then show_ammo_type = true end
        show_ammo_tag = ui_mcm.get("rax_ammo_check/show_ammo_tag")
        if show_ammo_tag == nil then show_ammo_tag = true end
        highlight_ammo_mode = ui_mcm.get("rax_ammo_check/highlight_ammo_mode") or 0
        print_dbg("Ammo settings: show_type=%s, show_tag=%s, highlight_mode=%s", tostring(show_ammo_type), tostring(show_ammo_tag), tostring(highlight_ammo_mode))
        msg_duration = ui_mcm.get("rax_ammo_check/msg_duration") or 2
        
        -- HUD settings
        hide_counter = ui_mcm.get("rax_ammo_check/hidecounter")
        if hide_counter == nil then hide_counter = true end
        hide_ammo_icon = ui_mcm.get("rax_ammo_check/hideicon")
        if hide_ammo_icon == nil then hide_ammo_icon = true end
        
        -- Behavior settings
        check_grenade_mode = ui_mcm.get("rax_ammo_check/check_grenade_mode")
        auto_check_reload = ui_mcm.get("rax_ammo_check/auto_check_reload")
        
        -- Animation settings
        local enable_val = ui_mcm.get("rax_ammo_check/enable_animations")
        enable_animations = (enable_val == true or enable_val == 1 or enable_val == nil)  -- Default true
        anim_mode = ui_mcm.get("rax_ammo_check/anim_mode") or 0
        no_magazine_fallback = ui_mcm.get("rax_ammo_check/no_magazine_fallback") or 1
        fake_reload_fallback = ui_mcm.get("rax_ammo_check/fake_reload_fallback") or 1
        local bolt_val = ui_mcm.get("rax_ammo_check/fake_reload_bolt_cycle")
        fake_reload_bolt_cycle = (bolt_val == true or bolt_val == 1 or bolt_val == nil)  -- Default true
        local bolt_eject_val = ui_mcm.get("rax_ammo_check/fake_reload_bolt_eject")
        fake_reload_bolt_eject = (bolt_eject_val == true or bolt_eject_val == 1)  -- Default false
        local pump_val = ui_mcm.get("rax_ammo_check/fake_reload_pump_rack")
        fake_reload_pump_rack = (pump_val == true or pump_val == 1 or pump_val == nil)  -- Default true
        local pump_eject_val = ui_mcm.get("rax_ammo_check/fake_reload_pump_eject")
        fake_reload_pump_eject = (pump_eject_val == true or pump_eject_val == 1)  -- Default false
        local ignore_val = ui_mcm.get("rax_ammo_check/fake_reload_ignore_list")
        fake_reload_ignore_list = (ignore_val == true or ignore_val == 1 or ignore_val == nil)  -- Default true
        busy_hands_delay = ui_mcm.get("rax_ammo_check/busy_hands_delay") or 1.5
        print_dbg("Animation settings: enable=%s, anim_mode=%s, no_mag_fb=%s, fake_fb=%s, bolt=%s, bolt_eject=%s, pump=%s, pump_eject=%s, ignore=%s", tostring(enable_animations), anim_mode, no_magazine_fallback, fake_reload_fallback, tostring(fake_reload_bolt_cycle), tostring(fake_reload_bolt_eject), tostring(fake_reload_pump_rack), tostring(fake_reload_pump_eject), tostring(fake_reload_ignore_list))
        
        -- Debug settings
        debug_mode = ui_mcm.get("rax_ammo_check/debug_mode")
        
        -- Keybind settings
        if mcm_keybinds then
            mcm_key = ui_mcm.get("rax_ammo_check/keybind")
            mode = ui_mcm.get("rax_ammo_check/mode") or 0
            modifier = ui_mcm.get("rax_ammo_check/modifier") or 0
            RegisterScriptCallback(modes[mode]["call"][1], this[modes[mode]["call"][1]])
            UnregisterScriptCallback(modes[mode]["call"][2], this[modes[mode]["call"][2]])
        end
    end

    -- Update HUD elements (cached access)
    local hud_states = ActorMenu.get_maingame().m_ui_hud_states
    local ammo_counter = hud_states.m_ui_weapon_cur_ammo
    local ammo_icon = hud_states.m_ui_weapon_icon

    local pos = ammo_counter:GetWndPos()
    pos.x = ((hide_counter and pos.x > 0) or ((not hide_counter) and pos.x < 0)) and (-1 * pos.x) or pos.x
    ammo_counter:SetWndPos(pos)

    pos = ammo_icon:GetWndPos()
    pos.x = ((hide_ammo_icon and pos.x > 0) or ((not hide_ammo_icon) and pos.x < 0)) and (-1 * pos.x) or pos.x
    ammo_icon:SetWndPos(pos)
    
    print_dbg("Options updated - display_mode: %s, color_intensity: %s, msg_duration: %s", display_mode, color_intensity, msg_duration)
end

-- Pending message globals for TimeEvent access --
local ac_pending_message = nil
local ac_pending_clr = nil
local ac_pending_ammo_type = nil
local ac_pending_separate_tag = nil
local ac_pending_slot = nil  -- For restore_weapon_callback

-- Pre-defined callback for delayed display --
local function delayed_display_callback()
    display_ammo_status(ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag)
    return true
end

-- Pre-defined callback for restore weapon after hide --
local function restore_weapon_callback()
    local actor = db.actor
    if not actor then return true end
    
    if actor:active_item() then
        return false  -- Wait for weapon to fully hide
    end
    
    if not weapon_hidden then
        actor:activate_slot(ac_pending_slot)
        return true
    end
    
    display_ammo_status(ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag)
    actor:activate_slot(ac_pending_slot)
    weapon_hidden = false
    return true
end

-- Restore detector after animation completes (checks weapon state) --
local function restore_detector_after_anim(weapon)
    if not weapon then 
        -- Weapon gone, just restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        return true 
    end
    
    -- Wait for weapon to return to idle (state 0)
    if weapon:get_state() ~= 0 then
        return false
    end
    
    -- Restore detector
    if det_active then
        db.actor:show_detector(true)
        det_active = nil
    end
    
    -- Clear animation state
    do_ammo_check_anim = nil
    wpn_checking = nil
    
    return true
end

-- ============================================
-- Fake Reload Animation System
-- Plays reload animation without actually reloading
-- ============================================

-- Restore ammo after fake reload animation completes --
local function restore_ammo_after_reload(weapon, count, pre_table)
    if not weapon then 
        do_ammo_check_anim = nil  -- Clear flag even if weapon gone
        return true 
    end
    if weapon:get_state() == 0 then
        weapon:set_ammo_elapsed(count)
        -- Refund ammo if MagsRedux is installed and we have a valid pre_table
        if pre_table and type(pre_table) == "table" and magazines and magazines.refund_ammo then
            magazines.refund_ammo(pre_table, weapon)  -- table first, then weapon
        end
        print_dbg("Fake reload complete, ammo restored: %s", count)
        
        -- Restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        
        -- Clear animation flag
        do_ammo_check_anim = nil
        
        return true
    end
    return false
end

-- Play HUD animation directly by name (like the first pickup inspect mod) --
-- This bypasses the state machine and plays the animation directly
local function play_hud_animation(weapon, anim_name, sound_param)
    local sec = weapon:section()
    
    -- Play the animation directly
    weapon:play_hud_motion(anim_name, true, 0, 1, 0)
    
    -- Play the associated sound if available
    if sound_param then
        local sound_file = ini_sys:r_string_ex(sec, sound_param)
        if sound_file and sound_file ~= "$no_sound" then
            local snd = sound_object(sound_file)
            if snd then
                snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
            end
        end
    end
    
    print_dbg("Playing HUD animation '%s' for %s", anim_name, sec)
end

-- Callback to play anm_close after anm_open finishes --
local function play_close_animation(weapon, sound_param)
    if not weapon then 
        -- Weapon gone, just restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        return true 
    end
    
    local sec = weapon:section()
    
    -- Play close animation
    weapon:play_hud_motion("anm_close", true, 0, 1, 0)
    
    -- Play associated sound if available
    if sound_param then
        local sound_file = ini_sys:r_string_ex(sec, sound_param)
        if sound_file and sound_file ~= "$no_sound" then
            local snd = sound_object(sound_file)
            if snd then
                snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
            end
        end
    end
    
    print_dbg("Playing anm_close for %s", sec)
    
    -- Schedule detector restoration
    CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
    
    return true
end

-- Play bolt/pump cycle animation (anm_open -> delay -> anm_close) --
-- delay_time: seconds to wait between open and close animations
local function play_open_close_animation(weapon, delay_time)
    local wpn_id = weapon:id()
    local sec = weapon:section()
    local delay = delay_time or 0.7  -- Default 0.7 seconds
    
    print_dbg("Bolt/pump cycle for %s: playing anm_open -> %.2fs -> anm_close", sec, delay)
    
    -- Play open animation with sound
    weapon:play_hud_motion("anm_open", true, 0, 1, 0)
    
    -- Play open sound if available
    local open_sound = ini_sys:r_string_ex(sec, "snd_open_weapon")
    if open_sound and open_sound ~= "$no_sound" then
        local snd = sound_object(open_sound)
        if snd then
            snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
        end
    end
    
    -- Schedule close animation after delay
    CreateTimeEvent("AmmoCheck_BoltCycle", "close"..wpn_id, delay, play_close_animation, weapon, "snd_close_weapon")
    
    return true
end

-- Play fake reload animation for weapons with detachable magazines --
-- This is only called when we KNOW the weapon uses magazines
local function play_reload_animation(weapon)
    local wpn_id = weapon:id()
    local sec = weapon:section()
    local current_ammo = weapon:get_ammo_in_magazine()
    
    -- MagsRedux path: handles magazines and chambered rounds properly
    if magazines and is_supported_weapon(sec) then
        local current_magazine = get_mag_loaded(wpn_id)
        
        -- Safely get ammo count table
        local pre_table = nil
        if magazines.count_ammo then
            local result = magazines.count_ammo(weapon)
            if type(result) == "table" then
                pre_table = result
            end
        end
        
        -- If one in the chamber, reloading will subtract a box of ammo and create a new dummy mag
        if not current_magazine and magazines.retain_round and magazines.retain_round(weapon) and (current_ammo > 0) then
            local oitc_ammo_sec = magazines.get_sec_chambered(weapon)
            local oitc_ammo_type = weapon:get_ammo_type()
            print_dbg("One (%s: %s) in the chamber and no magazine loaded.", oitc_ammo_type, oitc_ammo_sec)
            weapon:set_ammo_elapsed(0)
            weapon:switch_state(7)
            CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, 1, pre_table)
        else
            weapon:switch_state(7)
            CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, current_ammo, pre_table)
        end
    else
        -- Vanilla path: simple save/restore of ammo count
        print_dbg("Fake reload for vanilla weapon, ammo count: %s", current_ammo)
        weapon:switch_state(7)
        CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, current_ammo, nil)
    end
end

-- Silent ammo check (no weapon hide animation) - used for auto-check after reload --
function check_Ammo_silent()
    local actor = db.actor
    if not actor then return end
    
    local weapon = actor:active_item()
    if not weapon then return end
    if not IsWeapon(weapon) then return end
    if IsItem("fake_ammo_wpn", nil, weapon) then return end

    local weaponId = weapon:id()
    local sec = weapon:section()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    if in_grenade_mode and not check_grenade_mode then return end

    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return end

    -- Get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    
    -- Display directly
    display_ammo_status(message, clr, ammo_type, separate_tag)
end

-- Ammo check after reload (for OneKeyReload compatibility) --
-- Shows "Loaded" message after reload completes
function check_ammo_after_reload()
    local actor = db.actor
    if not actor then return true end
    
    local weapon = actor:active_item()
    if not weapon then return true end
    if not IsWeapon(weapon) then return true end
    if IsItem("fake_ammo_wpn", nil, weapon) then return true end
    
    local currentState = weapon:get_state()
    if not (currentState == 0 or weapon:weapon_in_grenade_mode()) then
        return false  -- Still reloading, try again
    end
    
    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return true end
    
    local weaponId = weapon:id()
    local sec = weapon:section()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    -- Get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    
    disable_info("sleep_active")
    
    -- Display with "Loaded" prefix
    if message then
        local loaded_msg = game.translate_string("st_ac_loaded") .. " " .. message
        if show_ammo_type and ammo_type then
            if separate_tag then
                loaded_msg = loaded_msg .. " " .. ammo_type
            else
                loaded_msg = ammo_type .. " " .. loaded_msg
            end
        end
        actor_menu.set_msg(1, loaded_msg, msg_duration, use_clr and clr or nil)
    end
    
    return true
end

-- ============================================
-- Weapon Configuration - External File
-- ============================================
-- Weapon exclusion lists are defined in ammo_check_weapons.script
-- This allows easy customization without modifying the main script.

local function get_break_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_break_action_config then
        return ammo_check_weapons.get_break_action_config(sec)
    end
    return nil
end

local function get_bolt_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_bolt_action_config then
        return ammo_check_weapons.get_bolt_action_config(sec)
    end
    return nil
end

local function get_pump_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_pump_action_config then
        return ammo_check_weapons.get_pump_action_config(sec)
    end
    return nil
end

local function should_ignore_fake_animations(sec)
    if ammo_check_weapons and ammo_check_weapons.should_ignore_fake_animations then
        return ammo_check_weapons.should_ignore_fake_animations(sec)
    end
    return false
end

-- Main ammo check function --
function check_Ammo(skip_animation)
    local actor = db.actor
    if not actor then return end
    
    local weapon = actor:active_item()
    
    -- Validation checks with early returns
    if not weapon then return end
    if not IsWeapon(weapon) then return end
    if IsItem("fake_ammo_wpn", nil, weapon) then return end

    local weaponId = weapon:id()
    local sec = weapon:section()
    local currentState = weapon:get_state()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    -- If weapon is busy (animation playing), just show message without animation
    local weapon_busy = (currentState ~= 0)
    
    -- If in grenade mode and check is disabled, return
    if in_grenade_mode and not check_grenade_mode then return end

    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return end

    -- Get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)

    disable_info("sleep_active")

    -- Store in globals for TimeEvent access
    ac_pending_message = message
    ac_pending_clr = clr
    ac_pending_ammo_type = ammo_type
    ac_pending_separate_tag = separate_tag

    -- Cleanup previous events
    RemoveTimeEvent("ammo_check", "message_delay")
    RemoveTimeEvent("ammo_check", "restore_weapon")
    RemoveTimeEvent("ammo_check", "restore_det")
    RemoveTimeEvent("AmmoCheck_BoltCycle", "close"..weaponId)
    
    -- Clear any lingering animation state
    do_ammo_check_anim = nil
    wpn_checking = nil
    
    -- ============================================
    -- ANIMATION LOGIC
    -- ============================================
    
    -- Check if weapon has PROPER custom mag inspect animation
    local has_proper_inspect = has_animation(sec, "anm_ammo_check") or 
                               has_animation(sec, "anm_ammo_check_empty") or
                               has_animation(sec, "anm_ammo_check_no_mag")
    
    -- If weapon busy or skip requested: just show message
    if skip_animation or weapon_busy then
        CreateTimeEvent("ammo_check", "message_delay", 0, delayed_display_callback)
        return
    end
    
    -- If animations are disabled: just show message with delay
    if not enable_animations then
        print_dbg("Ammo check for %s - animations disabled, showing message only.", sec)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- ============================================
    -- A) Weapon HAS proper mag inspect animation
    --    Let the native animation play, just show the message
    -- ============================================
    if has_proper_inspect then
        print_dbg("Ammo check for %s - has proper inspect animation, NOT interfering.", sec)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- ============================================
    -- B) Weapon DOES NOT have proper mag inspect animation
    --    Apply our alternative animation setting
    -- ============================================
    
    -- B.1) Default mode: hide/show weapon
    if anim_mode == 0 then
        print_dbg("Ammo check for %s - using hide/show weapon.", sec)
        ac_pending_slot = actor:active_slot()
        actor:activate_slot(0)
        weapon_hidden = true
        CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
        return
    end
    
    -- B.2) Lower weapon mode
    if anim_mode == 1 then
        print_dbg("Ammo check for %s - using lower weapon.", sec)
        game.actor_lower_weapon(true)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- B.3) Fake reload mode
    if anim_mode == 2 then
        -- Check if weapon should be ignored for fake reload animations
        if fake_reload_ignore_list and should_ignore_fake_animations(sec) then
            print_dbg("Ammo check for %s - in ignore list, using fake_reload_fallback=%s.", sec, fake_reload_fallback)
            
            if fake_reload_fallback == 0 then
                -- Hide/show weapon
                ac_pending_slot = actor:active_slot()
                actor:activate_slot(0)
                weapon_hidden = true
                CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
            else
                -- Lower weapon
                game.actor_lower_weapon(true)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
            end
            return
        end
        
        -- Check if weapon uses detachable magazines (MagsRedux supported)
        local uses_magazines = magazines and is_supported_weapon(sec)
        
        if uses_magazines then
            -- Check if this is a DETACHABLE magazine weapon vs INTERNAL magazine (tube, etc.)
            -- weapon_default_magazine returns nil for internal magazine weapons
            local has_detachable_mag = magazine_binder and magazine_binder.weapon_default_magazine and 
                                       magazine_binder.weapon_default_magazine(weapon)
            
            if has_detachable_mag then
                -- DETACHABLE magazine weapon - check if magazine is actually loaded
                local current_magazine = get_mag_loaded(weaponId)
                
                if current_magazine then
                    -- Has magazine - play fake reload animation
                    print_dbg("Ammo check for %s - detachable mag weapon with mag, using fake reload animation.", sec)
                    
                    do_ammo_check_anim = 1  -- Mark that we're doing our own animation
                    is_fake_reload = true   -- Prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    play_reload_animation(weapon)
                    CreateTimeEvent("ammo_check", "message_delay", FAKE_RELOAD_MSG_DELAY, delayed_display_callback)
                    return
                else
                    -- No magazine loaded - apply no_magazine_fallback
                    print_dbg("Ammo check for %s - detachable mag weapon, no mag, using no_magazine_fallback=%s.", sec, no_magazine_fallback)
                    
                    if no_magazine_fallback == 0 then
                        -- Hide/show weapon
                        ac_pending_slot = actor:active_slot()
                        actor:activate_slot(0)
                        weapon_hidden = true
                        CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
                    elseif no_magazine_fallback == 1 then
                        -- Lower weapon
                        game.actor_lower_weapon(true)
                        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                    else
                        -- None - just show message, no animation
                        CreateTimeEvent("ammo_check", "message_delay", 0, delayed_display_callback)
                    end
                    return
                end
            end
            -- else: Internal magazine weapon - fall through to exclusion lists below
            print_dbg("Ammo check for %s - internal magazine weapon (MagsRedux), checking exclusion lists.", sec)
        end
        
        -- ============================================
        -- Weapon does NOT use detachable magazines (internal magazine)
        -- Check exclusion lists for special handling
        -- ============================================
        
        -- Check 1: Break-action shotgun (TOZ-34 style)
        local break_config = get_break_action_config(sec)
        if break_config and has_animation(sec, break_config.anim) then
            print_dbg("Ammo check for %s - break-action, using %s animation.", sec, break_config.anim)
            
            do_ammo_check_anim = 1  -- Mark that we're doing our own animation
            is_fake_reload = true   -- Prevent auto-check duplicate
            
            det_active = actor:active_detector() or nil
            if det_active then
                det_active:switch_state(2)
            end
            
            play_hud_animation(weapon, break_config.anim, break_config.sound)
            
            CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
            CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
            return
        end
        
        -- Check 2: Bolt-action rifle (if MCM option enabled)
        if fake_reload_bolt_cycle then
            local bolt_config = get_bolt_action_config(sec)
            if bolt_config and has_animation(sec, "anm_open") and has_animation(sec, "anm_close") then
                print_dbg("Ammo check for %s - bolt-action, using open/close with %.2fs delay.", sec, bolt_config.delay)
                
                do_ammo_check_anim = 1  -- Mark that we're doing our own animation
                is_fake_reload = true   -- Prevent auto-check duplicate
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                -- Eject one round if option enabled and there's ammo
                if fake_reload_bolt_eject and currentAmmo > 0 then
                    local ammo_section = get_vanilla_ammo_section(weapon)
                    if ammo_section then
                        -- Remove one round from magazine
                        weapon:set_ammo_elapsed(currentAmmo - 1)
                        -- Give round to player inventory
                        alife_create_item(ammo_section, actor)
                        print_dbg("Ejected round: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                        
                        -- Update message to reflect new ammo count
                        ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                            get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                    end
                end
                
                play_open_close_animation(weapon, bolt_config.delay)
                CreateTimeEvent("ammo_check", "message_delay", bolt_config.delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                return
            end
        end
        
        -- Check 3: Pump-action shotgun (if MCM option enabled)
        if fake_reload_pump_rack then
            local pump_config = get_pump_action_config(sec)
            if pump_config and has_animation(sec, "anm_open") and has_animation(sec, "anm_close") then
                print_dbg("Ammo check for %s - pump-action, using open/close with %.2fs delay.", sec, pump_config.delay)
                
                do_ammo_check_anim = 1  -- Mark that we're doing our own animation
                is_fake_reload = true   -- Prevent auto-check duplicate
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                -- Eject one round if option enabled and there's ammo
                if fake_reload_pump_eject and currentAmmo > 0 then
                    local ammo_section = get_vanilla_ammo_section(weapon)
                    if ammo_section then
                        -- Remove one round from magazine
                        weapon:set_ammo_elapsed(currentAmmo - 1)
                        -- Give round to player inventory
                        alife_create_item(ammo_section, actor)
                        print_dbg("Ejected shell: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                        
                        -- Update message to reflect new ammo count
                        ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                            get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                    end
                end
                
                play_open_close_animation(weapon, pump_config.delay)
                CreateTimeEvent("ammo_check", "message_delay", pump_config.delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                return
            end
        end
        
        -- ============================================
        -- Fallback: Use fake_reload_fallback setting
        -- ============================================
        if fake_reload_fallback == 0 then
            -- Hide/show weapon
            print_dbg("Ammo check for %s - fallback to hide/show weapon.", sec)
            ac_pending_slot = actor:active_slot()
            actor:activate_slot(0)
            weapon_hidden = true
            CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
        else
            -- Lower weapon
            print_dbg("Ammo check for %s - fallback to lower weapon.", sec)
            game.actor_lower_weapon(true)
            CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        end
        return
    end
end

-- News system with deduplication --
local old_news = {}

function give_news(message)
    if old_news[message] then return end
    old_news[message] = true

    print_dbg(message)
    if db.actor then
        db.actor:give_game_news("AmmoCheck", message, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 5000, 0)
    end
end
