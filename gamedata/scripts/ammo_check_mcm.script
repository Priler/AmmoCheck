-- AmmoCheck (Enhanced)
-- Original: https://github.com/RAX-Anomaly/AmmoCheck
-- Original Authors: Ishmaeel, RavenAscendant, ahuyn, Utjan
-- Last modified: 2022.08.17
-- 
-- Enhanced by: Abraham (Priler)
-- Enhanced on: 2025.12.10
-- Repository: https://github.com/Priler/AmmoCheck
-- 
-- Changes:
--   - Performance optimizations (cached globals, reduced HUD access calls) * more info below
--   - Fixed duplicate callback registration bug
--   - Added display mode setting (text/numeric/both)
--   - Added message duration settings
--   - Added auto-check after reload
--   - Added color intensity adjustment
--   - Added grenade mode checking toggle
--   - Added configurable busy hands delay
--   - Added independent debug mode toggle
--	 - Added additional ammo tags ([FMJ], [AP]), [HP], etc.) + highlight of ammo type/ammo tag (optional)
--   - Added "fake reload" mag inspect animation (taken & re-written from "OneKeyReload" mod)
--   - Added custom weapons animation settings (for example, now Toz-34 Chimera Hunter also has a badass ammo check animation)
--   - Added fake reload exclusion list (Mag Palming, etc. animations will be excluded)
--   - Added "Eject round on bolt cyrcle" option
--   - Added "Eject shell on pump slide" option

--  @TODO:
--   - No magazine fallback only works for weapons without mag inspect animation
--   - (reason: I dunno how to cancel mag inspect animation, as well as how to cancel camera movement animation alongside it)
--   - (so if anyone know how to do it, write me (issues on GH would be good, or comment on ModDB))

--[[
    Performance optimizations (LUA *magic*):
    - Cached global function lookups for direct access
    - Cache of different things (Ammo type classification, Translation strings, is_supported_weapon results)
    - Shared code where it's possible/required
    - Some GC targeted optimizations (as few hot path allocations as possible, as few closures as possible, etc.)
    ...
	- etc. idk I hate LUA tbh xD (tf arrays starts with 1)
    - probably some more extreme perf optimizations could be made
    - but honestly, I hate GC languages so .. it'll work
]]



-- cached globals for perf
local math_floor = math.floor
local math_min = math.min
local math_max = math.max
local math_ceil = math.ceil
local string_find = string.find
local string_lower = string.lower
local string_format = string.format
local string_match = string.match
local string_sub = string.sub

-- forward declarations
local gc = game.translate_string

-- settings (defaults)
local use_clr = true
local hide_counter = true
local hide_ammo_icon = true
local anim_mode = 2             -- 0: default (hide/show), 1: lower weapon, 2: fake reload
local mcm_key = DIK_keys.DIK_T
local msg_duration = 2
local show_ammo_type = false
local show_ammo_tag = true
local busy_hands_delay = 1
local no_magazine_fallback = 1  -- 0: hide/show, 1: lower, 2: none (for Fake Reload mode when no mag loaded)
local fake_reload_fallback = 1  -- 0: hide/show, 1: lower (for internal mag weapons)
local empty_mag_fallback = 0    -- 0: reload anim (state=0), 1: anm_bore/idle, 2: lower weapon
local fake_reload_bolt_cycle = true  -- enable bolt cycle for bolt-action rifles
local fake_reload_bolt_eject = false -- eject one round when cycling bolt (realism)
local fake_reload_pump_rack = true   -- enable pump rack for pump-action shotguns
local fake_reload_pump_eject = false -- eject one round when racking slide (realism)
local fake_reload_ignore_list = true -- use ignore list for non-immersive fake reloads
local enable_animations = true       -- master switch for all animations
local check_grenade_mode = false
local display_mode = 0          -- 0: text, 1: numeric, 2: both
local auto_check_reload = false
local color_intensity = 70
local highlight_ammo_mode = 0   -- 0: none, 1: whole message, 2: separate lines
local debug_mode = false
local empty_mag_sound = nil     -- sound object for empty mag fake reload (to stop on cancel)

-- fake reload animation state
local do_ammo_check_anim = nil  -- nil: not active, 1: started, 2: mutator applied
local wpn_checking = nil        -- weapon being checked
local det_active = nil          -- detector that was active before check
local is_fake_reload = false    -- flag to prevent auto-check duplicate after fake reload

-- animation timing constants
local FAKE_RELOAD_MSG_DELAY = 1.5       -- delay before showing message after fake reload
local BOLT_PUMP_MSG_OFFSET = 0.8        -- additional delay offset for bolt/pump animations
local AUTO_CHECK_DELAY = 0.15           -- delay for auto-check after reload
local RESTORE_DET_DELAY = 0.1           -- delay before checking to restore detector

-- cached objects
local ZERO_VECTOR = vector():set(0, 0, 0)  -- reusable zero vector for sound positioning

-- debug numpad key mappings
local numpad_states = {
    [DIK_keys.DIK_NUMPAD0] = 0,
    [DIK_keys.DIK_NUMPAD1] = 1,
    [DIK_keys.DIK_NUMPAD2] = 2,
    [DIK_keys.DIK_NUMPAD3] = 3,
    [DIK_keys.DIK_NUMPAD4] = 4,
    [DIK_keys.DIK_NUMPAD5] = 5,
    [DIK_keys.DIK_NUMPAD6] = 6,
    [DIK_keys.DIK_NUMPAD7] = 7,
    [DIK_keys.DIK_NUMPAD8] = 8,
    [DIK_keys.DIK_NUMPAD9] = 9,
}

-- caches
local ammo_type_cache = {}      -- cache for ammo type classification
local translation_cache = {}    -- cache for translation strings
local ammo_list_cache = {}      -- cache for vanilla weapon ammo lists

-- color definitions
local function apply_intensity(color, intensity)
    if not color or intensity >= 100 then return color end
    local a = bit.band(bit.rshift(color, 24), 0xFF)
    local r = bit.band(bit.rshift(color, 16), 0xFF)
    local g = bit.band(bit.rshift(color, 8), 0xFF)
    local b = bit.band(color, 0xFF)
    local factor = intensity / 100
    r = math_floor(r * factor)
    g = math_floor(g * factor)
    b = math_floor(b * factor)
    return GetARGB(a, r, g, b)
end

-- base colors
local base_colors = {
    clr00_Red = GetARGB(0xff, 0xff, 0x00, 0x00),
    clr01_RedOrange = GetARGB(0xff, 0xff, 0x40, 0x00),
    clr02_Orange = GetARGB(0xff, 0xff, 0x80, 0x00),
    clr03_Amber = GetARGB(0xff, 0xff, 0xc0, 0x00),
    clr04_LemonGlacier = GetARGB(0xff, 0xff, 0xff, 0x00),
    clr05_LaserLemon = GetARGB(0xff, 0xff, 0xff, 0x80),
    clr06_White = GetARGB(0xff, 0xff, 0xff, 0xff),
}

-- active colors
local clr00_Red = base_colors.clr00_Red
local clr01_RedOrange = base_colors.clr01_RedOrange
local clr02_Orange = base_colors.clr02_Orange
local clr03_Amber = base_colors.clr03_Amber
local clr04_LemonGlacier = base_colors.clr04_LemonGlacier
local clr05_LaserLemon = base_colors.clr05_LaserLemon
local clr06_White = base_colors.clr06_White
local clrEE_Purple = utils_xml.get_color("d_purple", true)

-- base ammo type colors
local base_ammo_type_colors = {
    ap = GetARGB(0xff, 0x80, 0xc0, 0xff),       -- light blue
    hp = GetARGB(0xff, 0xff, 0xc0, 0x80),       -- light orange
    fmj = GetARGB(0xff, 0x80, 0xff, 0x80),      -- light green
    tracer = GetARGB(0xff, 0xff, 0xff, 0x80),   -- light yellow
    fire = GetARGB(0xff, 0xff, 0x80, 0x40),     -- orange-red
    sub = GetARGB(0xff, 0xa0, 0xa0, 0xff),      -- light purple
    enhanced = GetARGB(0xff, 0xc0, 0xff, 0xc0), -- pale green
    slug = GetARGB(0xff, 0xc0, 0xc0, 0xc0),     -- silver
    buck = GetARGB(0xff, 0xff, 0xa0, 0xa0),     -- light pink
}

-- active ammo type colors
local ammo_type_colors = {
    ap = base_ammo_type_colors.ap,
    hp = base_ammo_type_colors.hp,
    fmj = base_ammo_type_colors.fmj,
    tracer = base_ammo_type_colors.tracer,
    fire = base_ammo_type_colors.fire,
    sub = base_ammo_type_colors.sub,
    enhanced = base_ammo_type_colors.enhanced,
    slug = base_ammo_type_colors.slug,
    buck = base_ammo_type_colors.buck,
}

-- messages table
local messages = {}

-- must be defined before update_colors
local function rebuild_messages()
    messages = {
        { m = "st_ac_near_empty", c = clr00_Red },         -- <1/10
        { m = "st_ac_near_empty", c = clr01_RedOrange },   -- <2/10
        { m = "st_ac_less_half", c = clr01_RedOrange },    -- <3/10
        { m = "st_ac_less_half", c = clr02_Orange },       -- <4/10
        { m = "st_ac_about_half", c = clr02_Orange },      -- <5/10
        { m = "st_ac_about_half", c = clr03_Amber },       -- <6/10
        { m = "st_ac_more_half", c = clr03_Amber },        -- <7/10
        { m = "st_ac_more_half", c = clr04_LemonGlacier }, -- <8/10
        { m = "st_ac_nearly_full", c = clr04_LemonGlacier }, -- <9/10
        { m = "st_ac_nearly_full", c = clr05_LaserLemon }, -- <10/10
        { m = "st_ac_full", c = clr06_White }              -- full
    }
end
rebuild_messages() -- initialize

local function update_colors()
    clr00_Red = apply_intensity(base_colors.clr00_Red, color_intensity)
    clr01_RedOrange = apply_intensity(base_colors.clr01_RedOrange, color_intensity)
    clr02_Orange = apply_intensity(base_colors.clr02_Orange, color_intensity)
    clr03_Amber = apply_intensity(base_colors.clr03_Amber, color_intensity)
    clr04_LemonGlacier = apply_intensity(base_colors.clr04_LemonGlacier, color_intensity)
    clr05_LaserLemon = apply_intensity(base_colors.clr05_LaserLemon, color_intensity)
    clr06_White = apply_intensity(base_colors.clr06_White, color_intensity)
    -- rebuild messages table with new colors
    rebuild_messages()
    
    -- update ammo type colors with intensity
    ammo_type_colors.ap = apply_intensity(base_ammo_type_colors.ap, color_intensity)
    ammo_type_colors.hp = apply_intensity(base_ammo_type_colors.hp, color_intensity)
    ammo_type_colors.fmj = apply_intensity(base_ammo_type_colors.fmj, color_intensity)
    ammo_type_colors.tracer = apply_intensity(base_ammo_type_colors.tracer, color_intensity)
    ammo_type_colors.fire = apply_intensity(base_ammo_type_colors.fire, color_intensity)
    ammo_type_colors.sub = apply_intensity(base_ammo_type_colors.sub, color_intensity)
    ammo_type_colors.enhanced = apply_intensity(base_ammo_type_colors.enhanced, color_intensity)
    ammo_type_colors.slug = apply_intensity(base_ammo_type_colors.slug, color_intensity)
    ammo_type_colors.buck = apply_intensity(base_ammo_type_colors.buck, color_intensity)
    print_dbg("update_colors: intensity=%s, ap_color=%s", tostring(color_intensity), tostring(ammo_type_colors.ap))
end

-- cached translation lookup
local function get_translation(key)
    local cached = translation_cache[key]
    if cached then return cached end
    
    local translated = gc(key)
    translation_cache[key] = translated
    return translated
end

-- debug logging
local dbg_log
function print_dbg(msg, ...)
    if not debug_mode then
        if not mcm_log then
            return
        elseif not ui_mcm or not ui_mcm.MCM_DEBUG then
            return
        end
    end
    
    if not mcm_log then
        printf("![AC] " .. msg, ...)
    else
        if not dbg_log then
            dbg_log = mcm_log.new("![AC]")
            dbg_log.enabled = true
        end
        if dbg_log then dbg_log:log(msg, ...) end
    end
end

-- utility functions
function null_function()
    return false
end

-- nil-returning func for get_sec_chambered
local function nil_function()
    return nil
end

local function l_round(value)
    return math_floor(value + 0.5)
end

local function clamp(val, min_val, max_val)
    return math_min(math_max(val, min_val), max_val)
end

-- magsredux compat shim
function get_mag_loaded_shim(id)
    give_news(get_translation("st_ac_magsredux_update") or "You are using an older version of MagsRedux. Update to Github version for best experience.")
    local mag_data = get_data(id)
    return (mag_data and mag_data.section ~= "no_mag") and mag_data or nil
end

-- magsredux function refs
get_data = null_function
set_data = null_function
get_mag_loaded = null_function
is_supported_weapon = null_function
is_jammed_weapon = null_function
get_sec_chambered = nil_function  -- must return nil, not false

-- get current ammo section for vanilla weapons
-- uses caching to avoid repeated str_explode calls
local function get_vanilla_ammo_section(weapon)
    if not weapon then return nil end
    local sec = weapon:section()
    
    -- check cache first
    local cached_list = ammo_list_cache[sec]
    if cached_list == false then return nil end  -- cached "no ammo class"
    
    if not cached_list then
        local ammo_class = SYS_GetParam(0, sec, "ammo_class")
        if not ammo_class then 
            ammo_list_cache[sec] = false
            return nil 
        end
        cached_list = str_explode(ammo_class, ",")
        if not cached_list or #cached_list == 0 then
            ammo_list_cache[sec] = false
            return nil
        end
        ammo_list_cache[sec] = cached_list
    end
    
    -- get current ammo type index (0-based) and return section
    local ammo_type_idx = weapon:get_ammo_type()
    return cached_list[ammo_type_idx + 1]
end

-- keybind system
local mcm_keybinds = ui_mcm and ui_mcm.key_hold
local modifier = 0
local mode = 0

local modes = {
    [0] = { 
        ["call"] = { "on_key_press", "on_key_hold" }, 
        ["function"] = function(key) ui_mcm.simple_press("rax_ammo_check", key, check_Ammo) end 
    },
    [1] = { 
        ["call"] = { "on_key_press", "on_key_hold" }, 
        ["function"] = function(key) if ui_mcm.double_tap("rax_ammo_check", key) then check_Ammo() end end 
    },
    [2] = { 
        ["call"] = { "on_key_hold", "on_key_press" }, 
        ["function"] = function(key) if ui_mcm.key_hold("rax_ammo_check", key) then check_Ammo() end end 
    }
}

local direction_keys = {
    [key_bindings.kFWD] = true,
    [key_bindings.kBACK] = true,
    [key_bindings.kL_STRAFE] = true,
    [key_bindings.kACCEL] = true,
    [key_bindings.kR_STRAFE] = true
}

local weapon_hidden = false

function on_key_press(key)
    local bind = dik_to_bind(key)
    if weapon_hidden and not direction_keys[bind] then
        weapon_hidden = false
    end

    -- debug mode: numpad keys 0-9 test weapon states
    if debug_mode then
        if numpad_states[key] then
            debug_test_state(numpad_states[key])
            return
        end
        
        -- numpad * lists animations
        if key == DIK_keys.DIK_MULTIPLY then
            debug_list_animations()
            return
        end
        
        -- numpad + increases animation delay
        if key == DIK_keys.DIK_ADD then
            debug_adjust_delay(0.1)
            return
        end
        
        -- numpad - decreases animation delay
        if key == DIK_keys.DIK_SUBTRACT then
            debug_adjust_delay(-0.1)
            return
        end
        
        -- numpad / plays anm_bore
        if key == DIK_keys.DIK_DIVIDE then
            debug_play_animation("anm_bore")
            return
        end
        
        -- numpad . plays anm_idle
        if key == DIK_keys.DIK_DECIMAL then
            debug_play_animation("anm_idle")
            return
        end
    end

    if key ~= mcm_key then return end
    if not mcm_keybinds then
        check_Ammo()
        return
    end
    if ui_mcm.get_mod_key(modifier) then
        modes[mode]["function"](key)
    end
end

function on_key_hold(key)
    if key ~= mcm_key then return end
    if ui_mcm.get_mod_key(modifier) then
        modes[mode]["function"](key)
    end
end

-- message display
local function display_message(message, clr)
    if not message then return false end
    actor_menu.set_msg(1, message, msg_duration, clr)
    return true
end

-- ammo type classification
-- returns: type_key, display_tag
local function classify_ammo_type(section)
    if not section then return "unknown", nil end
    
    -- check cache first
    local cached = ammo_type_cache[section]
    if cached then
        return cached.type, cached.tag
    end
    
    local sec_lower = string_lower(section)
    local result_type = "unknown"
    local result_tag = nil
    
    -- AP (Armor Piercing): ap, pp, pbp, bp, 7h14, 7n, sp10, ss190, dart, barrikada
    if string_find(sec_lower, "_ap") 
       or string_find(sec_lower, "_bp") 
       or string_find(sec_lower, "_pbp")
       or string_find(sec_lower, "_pp")
       or string_find(sec_lower, "7h14")
       or string_find(sec_lower, "7n")
       or string_find(sec_lower, "sp10")
       or string_find(sec_lower, "ss190")
       or string_find(sec_lower, "_dart")
       or string_find(sec_lower, "barrikada") then
        result_type, result_tag = "ap", "(AP)"
    
    -- HP (Hollow Point): hp, jhp, hydro, sp (soft point)
    elseif string_find(sec_lower, "_hp") 
       or string_find(sec_lower, "jhp")
       or string_find(sec_lower, "hydro")
       or string_find(sec_lower, "_sp_") then
        result_type, result_tag = "hp", "(HP)"
    
    -- tracer
    elseif string_find(sec_lower, "_t_") 
       or string_find(sec_lower, "_tracer") then
        result_type, result_tag = "tracer", "(T)"
    
    -- incendiary/fire: fire, zp
    elseif string_find(sec_lower, "fire") 
       or string_find(sec_lower, "_zp") then
        result_type, result_tag = "fire", "(I)"
    
    -- subsonic
    elseif string_find(sec_lower, "sub") then
        result_type, result_tag = "sub", "(SUB)"
    
    -- match/enhanced: ep, pmm, pab9, 7h1
    elseif string_find(sec_lower, "_ep")
       or string_find(sec_lower, "_pmm")
       or string_find(sec_lower, "pab9")
       or string_find(sec_lower, "7h1") then
        result_type, result_tag = "enhanced", "(+)"
    
    -- slug (shotgun): slug, zhekan, shrapnel, eco
    elseif string_find(sec_lower, "slug")
       or string_find(sec_lower, "zhekan") 
       or string_find(sec_lower, "shrapnel")
       or string_find(sec_lower, "_eco") then
        result_type, result_tag = "slug", "(SL)"
    
    -- buckshot: buck, shot (but not shrapnel which is slug)
    elseif string_find(sec_lower, "buck") 
       or (string_find(sec_lower, "_shot") and not string_find(sec_lower, "shrapnel")) then
        result_type, result_tag = "buck", "(BK)"
    
    -- FMJ/ball/standard: fmj, ball, ps, p, ss195
    elseif string_find(sec_lower, "_fmj") 
       or string_find(sec_lower, "_ball")
       or string_find(sec_lower, "_ps")
       or string_match(sec_lower, "_p$")
       or string_find(sec_lower, "ss195") then
        result_type, result_tag = "fmj", "(FMJ)"
    end
    
    -- store in cache
    ammo_type_cache[section] = { type = result_type, tag = result_tag }
    return result_type, result_tag
end

-- get color for ammo type
local function get_ammo_type_color(ammo_type)
    return ammo_type_colors[ammo_type]
end

-- remove duplicate suffix if both ammo type and tag are shown from ammo name
-- e.g. "9x19 HP" + "(HP)" -> "9x19"
local function remove_duplicate_suffix(ammo_name, tag)
    if not ammo_name or not tag then return ammo_name end
    
    -- extract tag content without parentheses (e.g., "HP" from "(HP)")
    local tag_content = string_match(tag, "%((.+)%)")
    if not tag_content then return ammo_name end
    
    local name_len = #ammo_name
    local tag_len = #tag_content
    
    -- need at least space + tag length
    if name_len < tag_len + 1 then return ammo_name end
    
    -- check if ends with " TAG" (case-insensitive)
    local suffix_start = name_len - tag_len
    local potential_suffix = string_sub(ammo_name, suffix_start + 1)
    local char_before = string_sub(ammo_name, suffix_start, suffix_start)
    
    if char_before == " " and string_lower(potential_suffix) == string_lower(tag_content) then
        return string_sub(ammo_name, 1, suffix_start - 1)
    end
    
    return ammo_name
end

-- classify ammo type based on display name
-- returns: type_key, display_tag
local function classify_ammo_by_name(ammo_name)
    if not ammo_name or ammo_name == "" then return "unknown", nil end
    
    local name_lower = string_lower(ammo_name)
    
    -- HP variants
    if string_match(name_lower, " hp$") or string_match(name_lower, "hp$")
       or string_find(name_lower, "jhp") or string_find(name_lower, "hydro") then
        return "hp", "(HP)"
    end
    
    -- AP variants
    if string_match(name_lower, " ap$") or string_match(name_lower, "ap$")
       or string_match(name_lower, " bp$") or string_match(name_lower, "bp$")
       or string_match(name_lower, " pbp$") or string_find(name_lower, " pp")
       or string_find(name_lower, "sp10") or string_find(name_lower, "ss190") then
        return "ap", "(AP)"
    end
    
    -- 7N series (Russian AP designations - check separately)
    if string_find(name_lower, "7n") then
        return "ap", "(AP)"
    end
    
    -- tracer
    if string_find(name_lower, "tracer") or string_match(name_lower, " t$") then
        return "tracer", "(T)"
    end
    
    -- Incendiary
    if string_find(name_lower, "fire") or string_find(name_lower, "incend")
       or string_find(name_lower, " zp") then
        return "fire", "(I)"
    end
    
    -- subsonic
    if string_find(name_lower, "sub") then
        return "sub", "(SUB)"
    end
    
    -- Enhanced
    if string_match(name_lower, " ep$") or string_find(name_lower, "pmm")
       or string_find(name_lower, "match") then
        return "enhanced", "(+)"
    end
    
    -- Slug
    if string_find(name_lower, "slug") or string_find(name_lower, "zhekan")
       or string_find(name_lower, "shrapnel") or string_find(name_lower, "eco") then
        return "slug", "(SL)"
    end
    
    -- Buckshot
    if string_find(name_lower, "buck") or string_find(name_lower, "shot") then
        return "buck", "(BK)"
    end
    
    -- FMJ/Standard
    if string_find(name_lower, "fmj") or string_find(name_lower, "ball")
       or string_match(name_lower, " ps$") or string_match(name_lower, " p$") then
        return "fmj", "(FMJ)"
    end
    
    return "unknown", nil
end

-- format ammo type string for display
-- display_round: ammo section for name display
-- tag_round: ammo section for tag classification
-- returns: formatted_string, ammo_type_key, tag_for_separate_line
-- format ammo type string for display
-- display_round: ammo section for name display
-- tag_round: ammo section for tag classification
-- returns: formatted_string, ammo_type_key, tag_for_separate_line
local function format_ammo_type_string(display_round, tag_round)
    if not display_round and not tag_round then return "", nil, nil end
    
    local result = ""
    local separate_tag = nil
    local ammo_type = nil
    local tag = nil
    
    -- always get ammo name for tag classification
    -- prefer tag_round (magazine contents) for consistent classification
    local round_for_tag = tag_round or display_round
    local ammo_name_for_tag = nil
    if round_for_tag then
        ammo_name_for_tag = gc(ui_item.get_sec_short_name(round_for_tag))
        if ammo_name_for_tag == "" then
            ammo_name_for_tag = nil
        end
    end
    
    -- get tag from ammo name (more reliable than section)
    if ammo_name_for_tag then
        ammo_type, tag = classify_ammo_by_name(ammo_name_for_tag)
    end
    
    -- if no tag from name, try section-based classification as fallback
    if not tag and round_for_tag then
        ammo_type, tag = classify_ammo_type(round_for_tag)
    end
    
    -- get display name only if show_ammo_type is enabled
    local ammo_name_display = nil
    if show_ammo_type and ammo_name_for_tag then
        ammo_name_display = ammo_name_for_tag
    end
    
    -- remove duplicate suffix if both ammo type and tag are shown
    if ammo_name_display and show_ammo_tag and tag then
        ammo_name_display = remove_duplicate_suffix(ammo_name_display, tag)
    end
    
    -- determine what to show and how to highlight
    if show_ammo_tag and tag then
        -- tag is enabled - highlight applies to tag
        if highlight_ammo_mode == 2 then
            -- separate lines: ammo name on line 1, tag on line 2
            result = ammo_name_display or ""
            separate_tag = tag
        else
            -- none or whole: everything on one line
            if ammo_name_display then
                result = ammo_name_display .. " " .. tag
            else
                result = tag
            end
        end
    elseif show_ammo_type and ammo_name_display then
        -- tag disabled but ammo type enabled - highlight applies to ammo type name
        if highlight_ammo_mode == 2 then
            -- separate lines
            result = ""
            separate_tag = ammo_name_display
        else
            -- single line
            result = ammo_name_display
        end
    end
    
    return result, ammo_type, separate_tag
end

-- format ammo display based on display_mode
-- display_round: for ammo type name (chambered round)
-- tag_round: for ammo tag classification (magazine contents)
-- returns: message, ammo_type_key, tag_for_separate_line
local function format_ammo_message(text_msg, current, max, display_round, tag_round)
    local result
    
    if display_mode == 0 then
        -- text only
        result = get_translation(text_msg)
    elseif display_mode == 1 then
        -- numeric only
        result = string_format("%d/%d", current, max)
    else
        -- both
        result = string_format("%s (%d/%d)", get_translation(text_msg), current, max)
    end
    
    local ammo_type = nil
    local separate_tag = nil
    
    -- append ammo info if enabled and we have ammo
    if (show_ammo_type or show_ammo_tag) and (display_round or tag_round) then
        local ammo_str, atype, tag = format_ammo_type_string(display_round, tag_round)
        ammo_type = atype
        separate_tag = tag
        if ammo_str and ammo_str ~= "" then
            -- use comma only when ammo type name is shown
            local separator = show_ammo_type and ", " or " "
            result = result .. separator .. ammo_str
        end
    end
    
    return result, ammo_type, separate_tag
end

-- shared ammo status calculation
-- returns: message, color, ammo_type, separate_tag
local function get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    local message = ""
    local clr = nil
    local ammo_type = nil
    local separate_tag = nil
    
    local mag_data = get_mag_loaded(weaponId)
    local is_supported = is_supported_weapon(sec)
    
    -- determine weapon status and message
    if is_jammed_weapon(weapon) then
        message = get_translation("st_ac_jammed")
        clr = use_clr and clr00_Red or clr06_White
        
    elseif in_grenade_mode then
        message = currentAmmo == 1 and get_translation("st_ac_grenade") or get_translation("st_ac_empty")
        clr = use_clr and (currentAmmo == 1 and clr06_White or clr00_Red) or clr06_White
        
    elseif currentAmmo == 0 then
        if is_supported and not mag_data then
            message = get_translation("st_ac_noMag")
        else
            message = get_translation("st_ac_empty")
        end
        clr = use_clr and clr00_Red or clr06_White
        
    else
        local display_round = nil  -- For ammo type name
        local tag_round = nil      -- For ammo tag
        local max_ammo = 0
        local base_mag_size = SYS_GetParam(2, sec, "ammo_mag_size", 0)
        local is_chamber_only = false  -- Track if only chambered round remains
        local has_empty_mag = false    -- Track if magazine is inserted but empty

        if not mag_data and is_supported then
            -- no magazine inserted, one in the chamber
            currentAmmo = 1
            max_ammo = 10
            is_chamber_only = true
            has_empty_mag = false
        elseif is_supported and mag_data then
            print_dbg("Checking magazine section: %s", mag_data.section)
            max_ammo = SYS_GetParam(2, mag_data.section, "max_mag_size") or 1
            
            if magazines_mcm and magazines_mcm.get_config("retain_round") then
                -- with retain_round: last in array is chambered, second-to-last is magazine top
                local mag_top = mag_data.loaded[#mag_data.loaded - 1]
                if mag_top then
                    display_round = mag_top
                    tag_round = mag_top
                else
                    -- only chambered round left, magazine is empty
                    is_chamber_only = true
                    has_empty_mag = true
                end
            else
                -- without retain_round: top of stack is what we'll fire next
                -- check if stack module exists (MagsRedux dependency)
                if stack and stack.peek then
                    display_round = stack.peek(mag_data.loaded)
                elseif mag_data.loaded and #mag_data.loaded > 0 then
                    -- fallback: get last element directly
                    display_round = mag_data.loaded[#mag_data.loaded]
                end
                tag_round = display_round
            end
        else
            -- non-MagsRedux weapon: get ammo section from weapon's ammo_class list
            display_round = get_sec_chambered(weapon)
            -- fallback to vanilla method if MagsRedux function returned nil
            if not display_round then
                display_round = get_vanilla_ammo_section(weapon)
            end
            tag_round = display_round
            max_ammo = base_mag_size
        end

        -- guard against division by zero
        if not max_ammo or max_ammo <= 0 then max_ammo = 1 end
        
        local curAmmoPerc = currentAmmo / max_ammo

        if currentAmmo == max_ammo + 1 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_plus1", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clr06_White or clr06_White
            
        elseif curAmmoPerc > 1 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_overfull", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clrEE_Purple or clr06_White
            
        elseif currentAmmo == 1 and base_mag_size == 2 then
            message, ammo_type, separate_tag = format_ammo_message("st_ac_just_one", currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and clr03_Amber or clr06_White
            
        elseif is_chamber_only then
            -- Chamber only - don't show ammo type/tag
            if has_empty_mag then
                message = get_translation("st_ac_empty_mag_oitc")
            else
                message = get_translation("st_ac_no_mag_oitc")
            end
            clr = use_clr and clr00_Red or clr06_White
            
        else
            -- calculate index based on percentage
            -- use ceil so 20% maps to index 2 (near_empty), not index 3 (less_half)
            local idx
            if currentAmmo == max_ammo then
                idx = #messages -- Full
            else
                idx = clamp(math_ceil(curAmmoPerc * 10), 1, #messages - 1)
            end
            print_dbg("Ammo index: %s (%.1f%%, %d/%d)", idx, curAmmoPerc * 100, currentAmmo, max_ammo)
            
            message, ammo_type, separate_tag = format_ammo_message(messages[idx].m, currentAmmo, max_ammo, display_round, tag_round)
            clr = use_clr and messages[idx].c or clr06_White
            print_dbg("Color: use_clr=%s, idx=%s, clr=%s", tostring(use_clr), idx, tostring(clr))
        end
        
        -- apply ammo type color based on highlight mode
        -- only apply when Colored Messages is enabled
        if use_clr and ammo_type and highlight_ammo_mode == 1 then
            local ammo_clr = get_ammo_type_color(ammo_type)
            print_dbg("Highlight override: mode=%s, ammo_type=%s, ammo_clr=%s", highlight_ammo_mode, ammo_type, tostring(ammo_clr))
            if ammo_clr then
                clr = ammo_clr
            end
        end
    end
    
    return message, clr, ammo_type, separate_tag
end

-- display ammo status with optional second line
local function display_ammo_status(message, clr, ammo_type, separate_tag)
    display_message(message, clr)
    
    -- display separate tag line if mode 2
    if highlight_ammo_mode == 2 and separate_tag then
        local tag_clr = use_clr and get_ammo_type_color(ammo_type) or clr06_White
        actor_menu.set_msg(2, separate_tag, msg_duration, tag_clr)
    end
end

-- auto-check after reload
local pending_reload_check = false

-- callback for auto-check after reload
local function auto_check_after_reload_callback()
    local actor = db.actor
    if not actor then return true end
    
    local weapon = actor:active_item()
    if not weapon or not IsWeapon(weapon) then return true end
    
    -- Build and display message directly (no weapon hide animation)
    check_Ammo_silent()
    return true
end

-- callback for HUD animation end
function actor_on_hud_animation_end(item, section, motion, state, slot)
    -- stop empty mag sound if playing (handles cancelled animations)
    if empty_mag_sound and empty_mag_sound:playing() then
        empty_mag_sound:stop()
        empty_mag_sound = nil
    end
    
    if not auto_check_reload then return end
    if not motion then return end
    if not item then return end
    if not IsWeapon(item) then return end
    
    -- skip if this was a fake reload (we already displayed the message)
    if is_fake_reload then
        print_dbg("Skipping auto-check: was fake reload")
        is_fake_reload = false
        return
    end
    
    -- use case-insensitive pattern matching (avoids creating new string)
    -- check reload first (most common case)
    if string_find(motion, "[Rr]eload") then
        pending_reload_check = false
        print_dbg("Reload animation ended: %s", motion)
        CreateTimeEvent("ammo_check", "auto_check", AUTO_CHECK_DELAY, auto_check_after_reload_callback)
        return
    end
    
    -- check for shotgun open animation
    if string_find(motion, "[Oo]pen") and string_find(motion, "anm") then
        pending_reload_check = true
        print_dbg("Shotgun reload started: %s", motion)
        return
    end
    
    -- check for shotgun close animation (only if we're tracking a reload)
    if pending_reload_check and string_find(motion, "[Cc]lose") then
        pending_reload_check = false
        print_dbg("Shotgun reload ended: %s", motion)
        CreateTimeEvent("ammo_check", "auto_check", AUTO_CHECK_DELAY, auto_check_after_reload_callback)
    end
end

function actor_on_weapon_jammed(weapon)
    print_dbg("Weapon jammed")
end

-- ### ANIMATION MUTATOR FOR FAKE RELOAD

-- check if weapon has a specific HUD animation
local function has_animation(section, anm)
    local hud_section = SYS_GetParam(0, section, "hud") or section
    return SYS_GetParam(0, hud_section, anm)
end

-- animation mutator for fake reload - intercepts inspect animation
local function mag_check_animation(anm_table, obj)
    -- handle end of ammo check animation
    if wpn_checking and obj and wpn_checking:id() == obj:id() and do_ammo_check_anim == 2 then
        wpn_checking = nil
        do_ammo_check_anim = nil
        
        if det_active then
            db.actor:show_detector(true)
        end
        det_active = nil
    end
    
    -- handle start of ammo check animation (state 4 = inspect/bore)
    if do_ammo_check_anim == 1 and obj and obj:get_state() == 4 then
        wpn_checking = obj
        local sec = obj:section()
        
        local is_supported = is_supported_weapon(sec)
        local has_mag_data = get_mag_loaded(obj:id())
        
        -- try different ammo check animations
        -- if none exist, DON'T change the animation - let the default anm_bore play
        if animation_common and animation_common.has_animation then
            if is_supported and not has_mag_data and animation_common.has_animation(sec, "anm_ammo_check_no_mag") then
                anm_table.anm_name = "anm_ammo_check_no_mag"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            elseif obj:get_ammo_in_magazine() == 0 and animation_common.has_animation(sec, "anm_ammo_check_empty") then
                anm_table.anm_name = "anm_ammo_check_empty"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            elseif animation_common.has_animation(sec, "anm_ammo_check") then
                anm_table.anm_name = "anm_ammo_check"
                print_dbg("Ammo check animation mutated to: %s", anm_table.anm_name)
            else
                -- no ammo_check animation - let the default inspect animation play
                print_dbg("No ammo_check animation for %s, using default inspect: %s", sec, anm_table.anm_name)
            end
        end
        
        do_ammo_check_anim = 2
    end
end

-- game initialization
function on_game_start()
    -- setup MagsRedux integration
    if magazine_binder then
        get_data = magazine_binder.get_data
        set_data = magazine_binder.set_data
        get_mag_loaded = magazine_binder.get_mag_loaded or get_mag_loaded_shim
        is_supported_weapon = magazine_binder.is_supported_weapon
        is_jammed_weapon = magazines.is_jammed_weapon
        get_sec_chambered = magazines.get_sec_chambered
        print_dbg("MagsRedux installed. Working in integrated mode.")
    else
        get_data = null_function
        set_data = null_function
        is_supported_weapon = null_function
        get_mag_loaded = null_function
        is_jammed_weapon = null_function
        get_sec_chambered = nil_function  -- must return nil, not false
        print_dbg("MagsRedux not found. Working in standalone mode.")
    end

    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("actor_on_hud_animation_end", actor_on_hud_animation_end)
    RegisterScriptCallback("actor_on_weapon_jammed", actor_on_weapon_jammed)
    
    -- register animation mutator for fake reload mode
    if animation_common and animation_common.add_anim_mutator then
        animation_common.add_anim_mutator(mag_check_animation, 2)
        print_dbg("Animation mutator registered: mag_check_animation (priority 2)")
    end
end

-- ### ANIMATION DEBUG SYSTEM
-- when debug mode is ON:
--   numpad 0-9 = test weapon state 0-9
--   numpad * = list all animations for current weapon
--   numpad + = increase bolt/pump animation delay (+0.1s)
--   numpad - = decrease bolt/pump animation delay (-0.1s)
--   numpad / = play anm_bore animation
--   numpad . = play anm_idle animation

-- debug: test different weapon states
function debug_test_state(state_num)
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    local current_state = weapon:get_state()
    
    -- Only switch if weapon is idle
    if current_state ~= 0 then
        db.actor:give_game_news("AmmoCheck Debug", "Weapon not idle! State: " .. current_state, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    db.actor:give_game_news("AmmoCheck Debug", "Testing state " .. state_num .. " on " .. sec, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
    weapon:switch_state(state_num)
end

-- debug: list all animations for current weapon
function debug_list_animations()
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    local hud_section = ini_sys:r_string_ex(sec, "hud") or sec
    
    local animations_to_check = {
        "anm_idle", "anm_reload", "anm_reload_empty",
        "anm_open", "anm_close", "anm_add_cartridge",
        "anm_bore", "anm_shots", "anm_shoot",
        "anm_ammo_check", "anm_ammo_check_empty", "anm_ammo_check_no_mag",
    }
    
    local found = {}
    for _, anm in ipairs(animations_to_check) do
        local value = SYS_GetParam(0, hud_section, anm)
        if value then
            table.insert(found, anm)
        end
    end
    
    local msg = sec .. ":\\n" .. table.concat(found, ", ")
    db.actor:give_game_news("AmmoCheck Debug - Animations", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 8000, 0)
    
    -- also print to console for full details
    printf("[AmmoCheck DEBUG] Weapon: %s | HUD: %s", sec, hud_section)
    for _, anm in ipairs(found) do
        printf("  [+] %s", anm)
    end
end

-- debug: adjust animation delay for bolt/pump weapons
function debug_adjust_delay(delta)
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    
    if not ammo_check_weapons then
        db.actor:give_game_news("AmmoCheck Debug", "Weapons config not loaded!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    if not ammo_check_weapons.adjust_delay then
        db.actor:give_game_news("AmmoCheck Debug", "adjust_delay not available!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local new_delay, weapon_type = ammo_check_weapons.adjust_delay(sec, delta)
    
    if new_delay then
        local type_name = weapon_type == "bolt" and "Bolt-action" or "Pump-action"
        local msg = string.format("%s delay: %.1fs", type_name, new_delay)
        db.actor:give_game_news("AmmoCheck Debug", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 2000, 0)
        printf("[AmmoCheck DEBUG] %s %s delay set to %.1fs", sec, weapon_type, new_delay)
    else
        db.actor:give_game_news("AmmoCheck Debug", "Weapon not in bolt/pump lists: " .. sec, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
    end
end

function debug_play_animation(anim_name)
    local weapon = db.actor and db.actor:active_item()
    if not weapon or not IsWeapon(weapon) then
        db.actor:give_game_news("AmmoCheck Debug", "No weapon active!", "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local sec = weapon:section()
    
    -- Check if weapon has this animation
    local hud_sec = ini_sys:r_string_ex(sec, "hud")
    if not hud_sec then
        db.actor:give_game_news("AmmoCheck Debug", "No HUD section for: " .. sec, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    local anim_exists = ini_sys:r_string_ex(hud_sec, anim_name)
    if not anim_exists then
        local msg = string.format("%s: no '%s' animation", sec, anim_name)
        db.actor:give_game_news("AmmoCheck Debug", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        return
    end
    
    -- play the animation with error protection
    local success, err = pcall(function()
        weapon:play_hud_motion(anim_name, true, 0, 1, 0)
    end)
    
    if not success then
        local msg = string.format("Failed to play '%s' on %s", anim_name, sec)
        db.actor:give_game_news("AmmoCheck Debug", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 3000, 0)
        printf("[AmmoCheck DEBUG] %s: %s", msg, tostring(err))
        return
    end
    
    local msg = string.format("Playing '%s' on %s", anim_name, sec)
    db.actor:give_game_news("AmmoCheck Debug", msg, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 2000, 0)
    printf("[AmmoCheck DEBUG] %s", msg)
end

-- MCM configuration
function on_mcm_load()
    return {
        id = "rax_ammo_check",
        sh = true,
        gr = {
            -- header
            { id = "ammo_check", type = "slide", link = "ui_options_slider_player", text = "ui_mm_title_rax_ammo_check", size = { 512, 50 }, spacing = 20 },
            
            -- display
            { id = "divider_display", type = "line" },
            { id = "title_display", type = "title", text = "ui_mcm_rax_ammo_check_title_display" },
            { id = "usecolor", type = "check", val = 1, def = true },
            { id = "color_intensity", type = "track", val = 2, min = 30, max = 100, step = 10, def = 70 },
            { id = "display_mode", type = "list", val = 2, def = 0, 
                content = { 
                    { 0, "dm_text" }, 
                    { 1, "dm_numeric" }, 
                    { 2, "dm_both" } 
                } 
            },
            { id = "show_ammo_type", type = "check", val = 1, def = false },
            { id = "show_ammo_tag", type = "check", val = 1, def = true },
            { id = "highlight_ammo_mode", type = "list", val = 2, def = 0,
                content = {
                    { 0, "ham_none" },
                    { 1, "ham_whole" },
                    { 2, "ham_separate" }
                }
            },
            { id = "msg_duration", type = "track", val = 2, min = 1, max = 5, step = 0.5, def = 2 },
            
            -- hud
            { id = "divider_hud", type = "line" },
            { id = "title_hud", type = "title", text = "ui_mcm_rax_ammo_check_title_hud" },
            { id = "hidecounter", type = "check", val = 1, def = true },
            { id = "hideicon", type = "check", val = 1, def = true },
            
            -- behavior
            { id = "divider_behavior", type = "line" },
            { id = "title_behavior", type = "title", text = "ui_mcm_rax_ammo_check_title_behavior" },
            { id = "check_grenade_mode", type = "check", val = 1, def = false },
            { id = "auto_check_reload", type = "check", val = 1, def = false },
            
            -- animation
            { id = "divider_anim", type = "line" },
            { id = "title_anim", type = "title", text = "ui_mcm_rax_ammo_check_title_anim" },
            { id = "enable_animations", type = "check", val = 1, def = true },
            { id = "anim_mode", type = "list", val = 2, def = 2,
                content = {
                    { 0, "anim_mode_default" },
                    { 1, "anim_mode_lower" },
                    { 2, "anim_mode_fake_reload" }
                }
            },
            { id = "no_magazine_fallback", type = "list", val = 2, def = 1,
                content = {
                    { 0, "fallback_hide_show" },
                    { 1, "fallback_lower" },
                    { 2, "fallback_none" }
                }
            },
            { id = "fake_reload_fallback", type = "list", val = 2, def = 1,
                content = {
                    { 0, "fallback_hide_show" },
                    { 1, "fallback_lower" }
                }
            },
            { id = "empty_mag_fallback", type = "list", val = 2, def = 0,
                content = {
                    { 0, "empty_mag_reload_anim" },
                    { 1, "empty_mag_animate" },
                    { 2, "empty_mag_lower" }
                }
            },
            { id = "fake_reload_bolt_cycle", type = "check", val = 1, def = true },
            { id = "fake_reload_bolt_eject", type = "check", val = 1, def = false },
            { id = "fake_reload_pump_rack", type = "check", val = 1, def = true },
            { id = "fake_reload_pump_eject", type = "check", val = 1, def = false },
            { id = "fake_reload_ignore_list", type = "check", val = 1, def = true },
            { id = "busy_hands_delay", type = "track", val = 2, min = 0.5, max = 3, step = 0.25, def = 1 },
            
            -- keybind
            { id = "divider_keys", type = "line" },
            { id = "title_keys", type = "title", text = "ui_mcm_rax_ammo_check_title_keys" },
            { id = "keybind", type = "key_bind", val = 2, def = DIK_keys.DIK_F },
            { id = "modifier", type = ui_mcm.kb_mod_radio, val = 2, def = 0, hint = "mcm_kb_modifier", 
                content = { { 0, "mcm_kb_mod_none" }, { 1, "mcm_kb_mod_shift" }, { 3, "mcm_kb_mod_alt" } } 
            },
            { id = "mode", type = ui_mcm.kb_mod_radio, val = 2, def = 2, hint = "mcm_kb_mode", 
                content = { { 0, "mcm_kb_mode_press" }, { 1, "mcm_kb_mode_dtap" }, { 2, "mcm_kb_mode_hold" } } 
            },
            { id = "desc_mcm", type = "desc", text = "ui_mcm_rax_ammo_check_update_mcm", clr = { 255, 175, 0, 0 }, 
                precondition = { function() return not mcm_keybinds end } 
            },
            
            -- debug
            { id = "divider_debug", type = "line" },
            { id = "title_debug", type = "title", text = "ui_mcm_rax_ammo_check_title_debug" },
            { id = "debug_mode", type = "check", val = 1, def = false },
        }
    }
end

function actor_on_first_update()
    on_option_change()
end

function on_option_change()
    -- clear caches when settings change
    ammo_type_cache = {}
    translation_cache = {}
    
    if ui_mcm then
        -- display settings
        local clr_val = ui_mcm.get("rax_ammo_check/usecolor")
        -- MCM might return true/false, 1/0, or nil
        use_clr = (clr_val == true or clr_val == 1)
        color_intensity = ui_mcm.get("rax_ammo_check/color_intensity") or 100
        update_colors() -- apply color intensity changes
        print_dbg("Settings loaded: use_clr=%s (raw=%s), color_intensity=%s", tostring(use_clr), tostring(clr_val), tostring(color_intensity))
        display_mode = ui_mcm.get("rax_ammo_check/display_mode") or 0
        show_ammo_type = ui_mcm.get("rax_ammo_check/show_ammo_type")
        if show_ammo_type == nil then show_ammo_type = true end
        show_ammo_tag = ui_mcm.get("rax_ammo_check/show_ammo_tag")
        if show_ammo_tag == nil then show_ammo_tag = true end
        highlight_ammo_mode = ui_mcm.get("rax_ammo_check/highlight_ammo_mode") or 0
        print_dbg("Ammo settings: show_type=%s, show_tag=%s, highlight_mode=%s", tostring(show_ammo_type), tostring(show_ammo_tag), tostring(highlight_ammo_mode))
        msg_duration = ui_mcm.get("rax_ammo_check/msg_duration") or 2
        
        -- hud settings
        hide_counter = ui_mcm.get("rax_ammo_check/hidecounter")
        if hide_counter == nil then hide_counter = true end
        hide_ammo_icon = ui_mcm.get("rax_ammo_check/hideicon")
        if hide_ammo_icon == nil then hide_ammo_icon = true end
        
        -- behavior settings
        check_grenade_mode = ui_mcm.get("rax_ammo_check/check_grenade_mode")
        auto_check_reload = ui_mcm.get("rax_ammo_check/auto_check_reload")
        
        -- animation settings
        local enable_val = ui_mcm.get("rax_ammo_check/enable_animations")
        enable_animations = (enable_val == true or enable_val == 1 or enable_val == nil)  -- default true
        anim_mode = ui_mcm.get("rax_ammo_check/anim_mode") or 0
        no_magazine_fallback = ui_mcm.get("rax_ammo_check/no_magazine_fallback") or 1
        fake_reload_fallback = ui_mcm.get("rax_ammo_check/fake_reload_fallback") or 1
        empty_mag_fallback = ui_mcm.get("rax_ammo_check/empty_mag_fallback") or 0
        local bolt_val = ui_mcm.get("rax_ammo_check/fake_reload_bolt_cycle")
        fake_reload_bolt_cycle = (bolt_val == true or bolt_val == 1 or bolt_val == nil)  -- default true
        local bolt_eject_val = ui_mcm.get("rax_ammo_check/fake_reload_bolt_eject")
        fake_reload_bolt_eject = (bolt_eject_val == true or bolt_eject_val == 1)  -- default false
        local pump_val = ui_mcm.get("rax_ammo_check/fake_reload_pump_rack")
        fake_reload_pump_rack = (pump_val == true or pump_val == 1 or pump_val == nil)  -- default true
        local pump_eject_val = ui_mcm.get("rax_ammo_check/fake_reload_pump_eject")
        fake_reload_pump_eject = (pump_eject_val == true or pump_eject_val == 1)  -- default false
        local ignore_val = ui_mcm.get("rax_ammo_check/fake_reload_ignore_list")
        fake_reload_ignore_list = (ignore_val == true or ignore_val == 1 or ignore_val == nil)  -- default true
        busy_hands_delay = ui_mcm.get("rax_ammo_check/busy_hands_delay") or 1.5
        print_dbg("Animation settings: enable=%s, anim_mode=%s, no_mag_fb=%s, fake_fb=%s, bolt=%s, bolt_eject=%s, pump=%s, pump_eject=%s, ignore=%s", tostring(enable_animations), anim_mode, no_magazine_fallback, fake_reload_fallback, tostring(fake_reload_bolt_cycle), tostring(fake_reload_bolt_eject), tostring(fake_reload_pump_rack), tostring(fake_reload_pump_eject), tostring(fake_reload_ignore_list))
        
        -- debug settings
        debug_mode = ui_mcm.get("rax_ammo_check/debug_mode")
        
        -- keybind settings
        if mcm_keybinds then
            mcm_key = ui_mcm.get("rax_ammo_check/keybind")
            mode = ui_mcm.get("rax_ammo_check/mode") or 0
            modifier = ui_mcm.get("rax_ammo_check/modifier") or 0
            RegisterScriptCallback(modes[mode]["call"][1], this[modes[mode]["call"][1]])
            UnregisterScriptCallback(modes[mode]["call"][2], this[modes[mode]["call"][2]])
        end
    end

    -- update HUD elements (cached access)
    local hud_states = ActorMenu.get_maingame().m_ui_hud_states
    local ammo_counter = hud_states.m_ui_weapon_cur_ammo
    local ammo_icon = hud_states.m_ui_weapon_icon

    local pos = ammo_counter:GetWndPos()
    pos.x = ((hide_counter and pos.x > 0) or ((not hide_counter) and pos.x < 0)) and (-1 * pos.x) or pos.x
    ammo_counter:SetWndPos(pos)

    pos = ammo_icon:GetWndPos()
    pos.x = ((hide_ammo_icon and pos.x > 0) or ((not hide_ammo_icon) and pos.x < 0)) and (-1 * pos.x) or pos.x
    ammo_icon:SetWndPos(pos)
    
    print_dbg("Options updated - display_mode: %s, color_intensity: %s, msg_duration: %s", display_mode, color_intensity, msg_duration)
end

-- pending message globals for TimeEvent access
local ac_pending_message = nil
local ac_pending_clr = nil
local ac_pending_ammo_type = nil
local ac_pending_separate_tag = nil
local ac_pending_slot = nil  -- for restore_weapon_callback

-- pre-defined callback for delayed display
local function delayed_display_callback()
    display_ammo_status(ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag)
    return true
end

-- pre-defined callback for restore weapon after hide
local function restore_weapon_callback()
    local actor = db.actor
    if not actor then return true end
    
    if actor:active_item() then
        return false  -- wait for weapon to fully hide
    end
    
    if not weapon_hidden then
        actor:activate_slot(ac_pending_slot)
        return true
    end
    
    display_ammo_status(ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag)
    actor:activate_slot(ac_pending_slot)
    weapon_hidden = false
    return true
end

-- restore detector after animation completes (checks weapon state)
local function restore_detector_after_anim(weapon)
    if not weapon then 
        -- weapon gone, just restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        return true 
    end
    
    -- wait for weapon to return to idle (state 0)
    if weapon:get_state() ~= 0 then
        return false
    end
    
    -- restore detector
    if det_active then
        db.actor:show_detector(true)
        det_active = nil
    end
    
    -- clear animation state
    do_ammo_check_anim = nil
    wpn_checking = nil
    
    return true
end

-- ### FAKE RELOAD ANIMATION SYSTEM
-- plays reload animation without actually reloading

-- restore ammo after fake reload animation completes
local restore_retry_count = 0
local MAX_RESTORE_RETRIES = 50  -- ~5 seconds at 0.1s interval

local function restore_ammo_after_reload(weapon, count, pre_table, wpn_id)
    local weapon_id = wpn_id or (weapon and weapon:id())
    
    -- increment retry counter
    restore_retry_count = restore_retry_count + 1
    
    -- safety: timeout after too many retries
    if restore_retry_count > MAX_RESTORE_RETRIES then
        print_dbg("Fake reload timeout - cleaning up")
        restore_retry_count = 0
        do_ammo_check_anim = nil
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        -- don't restore ammo on timeout - player may have reloaded manually
        return true
    end
    
    -- get weapon by ID if object is gone
    if not weapon and weapon_id then
        weapon = level.object_by_id(weapon_id)
    end
    
    -- check if weapon object is still valid
    if not weapon then 
        print_dbg("Fake reload: weapon gone, cleaning up")
        restore_retry_count = 0
        do_ammo_check_anim = nil
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        return true 
    end
    
    -- check weapon state - if idle or weapon was switched, restore ammo
    local active_item = db.actor and db.actor:active_item()
    local is_active = active_item and active_item:id() == weapon:id()
    local is_idle = weapon:get_state() == 0
    
    -- restore if weapon is idle OR if weapon was switched (cancel scenario)
    if is_idle or not is_active then
        -- safety check: only restore if current ammo matches what we expect
        -- prevents wiping ammo if player manually reloaded
        local current_ammo = weapon:get_ammo_in_magazine()
        if count == 0 and current_ammo ~= 1 then
            -- we were restoring to 0 (empty mag trick) but ammo is no longer 1
            -- player probably reloaded manually, don't wipe their ammo
            print_dbg("Fake reload: ammo changed (%d -> %d), skipping restore", 1, current_ammo)
        else
            weapon:set_ammo_elapsed(count)
            -- refund ammo if MagsRedux is installed and we have a valid pre_table
            if pre_table and type(pre_table) == "table" and magazines and magazines.refund_ammo then
                magazines.refund_ammo(pre_table, weapon)
            end
            print_dbg("Fake reload complete, ammo restored: %s (idle=%s, active=%s)", count, tostring(is_idle), tostring(is_active))
        end
        
        -- restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        
        -- clear flags
        restore_retry_count = 0
        do_ammo_check_anim = nil
        
        return true
    end
    return false
end

-- play HUD animation directly by name
-- this bypasses the state machine and plays the animation directly
local function play_hud_animation(weapon, anim_name, sound_param)
    local sec = weapon:section()
    
    -- safety check: verify animation exists before playing
    local hud_sec = ini_sys:r_string_ex(sec, "hud")
    if not hud_sec then
        print_dbg("play_hud_animation: No HUD section for %s, skipping", sec)
        return false
    end
    
    local anim_exists = ini_sys:r_string_ex(hud_sec, anim_name)
    if not anim_exists then
        print_dbg("play_hud_animation: Animation '%s' not found in %s, skipping", anim_name, sec)
        return false
    end
    
    -- play the animation with error protection
    local success, err = pcall(function()
        weapon:play_hud_motion(anim_name, true, 0, 1, 0)
    end)
    
    if not success then
        print_dbg("play_hud_animation: Failed to play '%s' on %s: %s", anim_name, sec, tostring(err))
        return false
    end
    
    -- play the associated sound if available
    if sound_param then
        local sound_file = ini_sys:r_string_ex(sec, sound_param)
        if sound_file and sound_file ~= "$no_sound" then
            local snd = sound_object(sound_file)
            if snd then
                snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
            end
        end
    end
    
    print_dbg("Playing HUD animation '%s' for %s", anim_name, sec)
    return true
end

-- callback to play anm_close after anm_open finishes
local function play_close_animation(weapon, sound_param)
    if not weapon then 
        -- weapon gone, just restore detector
        if det_active then
            db.actor:show_detector(true)
            det_active = nil
        end
        return true 
    end
    
    local sec = weapon:section()
    
    -- play close animation with error protection
    local success, err = pcall(function()
        weapon:play_hud_motion("anm_close", true, 0, 1, 0)
    end)
    
    if not success then
        print_dbg("play_close_animation: Failed to play anm_close on %s: %s", sec, tostring(err))
    end
    
    -- play sound
    if sound_param then
        local sound_file = ini_sys:r_string_ex(sec, sound_param)
        if sound_file and sound_file ~= "$no_sound" then
            local snd = sound_object(sound_file)
            if snd then
                snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
            end
        end
    end
    
    print_dbg("Playing anm_close for %s", sec)
    
    -- schedule detector restoration
    CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
    
    return true
end

-- play bolt/pump cycle animation (anm_open -> delay -> anm_close)
-- delay_time: seconds to wait between open and close animations
local function play_open_close_animation(weapon, delay_time)
    local wpn_id = weapon:id()
    local sec = weapon:section()
    local delay = delay_time or 0.7  -- default 0.7 seconds
    
    print_dbg("Bolt/pump cycle for %s: playing anm_open -> %.2fs -> anm_close", sec, delay)
    
    -- play open animation with error protection
    local success, err = pcall(function()
        weapon:play_hud_motion("anm_open", true, 0, 1, 0)
    end)
    
    if not success then
        print_dbg("play_open_close_animation: Failed to play anm_open on %s: %s", sec, tostring(err))
        return false
    end
    
    -- play open sound if available
    local open_sound = ini_sys:r_string_ex(sec, "snd_open_weapon")
    if open_sound and open_sound ~= "$no_sound" then
        local snd = sound_object(open_sound)
        if snd then
            snd:play_no_feedback(db.actor, sound_object.s2d, 0, ZERO_VECTOR, 1.0, 1.0)
        end
    end
    
    -- schedule close animation after delay
    CreateTimeEvent("AmmoCheck_BoltCycle", "close"..wpn_id, delay, play_close_animation, weapon, "snd_close_weapon")
    
    return true
end

-- play fake reload animation for weapons with detachable magazines
-- this is only called when we KNOW the weapon uses magazines
local function play_reload_animation(weapon)
    local wpn_id = weapon:id()
    local sec = weapon:section()
    local current_ammo = weapon:get_ammo_in_magazine()
    
    -- if magazine is empty, we CANNOT use switch_state(7) - it triggers real reload
    -- but we CAN use play_hud_motion with state=7 to play animation with pending flag
    -- unlike switch_state(7), play_hud_motion doesn't trigger the reload state machine
    if current_ammo == 0 then
        if empty_mag_fallback == 0 then
            -- try reload animation (using play_hud_motion which doesn't trigger reload logic)
            -- temporarily set ammo to 1 so animation_common doesn't switch to anm_reload_empty
            print_dbg("Fake reload for empty mag weapon %s, using reload animation", sec)
            if has_animation(sec, "anm_reload") then
                weapon:set_ammo_elapsed(1)  -- trick animation selection
                -- use state=7 to set pending flag (prevents movement interruption)
                -- play_hud_motion doesn't call switch2_Reload so no actual reload happens
                local success, err = pcall(function()
                    weapon:play_hud_motion("anm_reload", true, 7, 1, 0)
                end)
                weapon:set_ammo_elapsed(0)  -- restore immediately
                
                if success then
                    -- play sound manually - store it so we can stop on cancel
                    local sound_file = ini_sys:r_string_ex(sec, "snd_reload")
                    if sound_file and sound_file ~= "$no_sound" then
                        -- stop any previous sound
                        if empty_mag_sound and empty_mag_sound:playing() then
                            empty_mag_sound:stop()
                        end
                        empty_mag_sound = sound_object(sound_file)
                        if empty_mag_sound then
                            empty_mag_sound:play(db.actor, 0, sound_object.s2d)
                        end
                    end
                end
            elseif has_animation(sec, "anm_bore") then
                play_hud_animation(weapon, "anm_bore", "snd_bore")
            else
                game.actor_lower_weapon(true)
            end
        elseif empty_mag_fallback == 1 then
            -- use anm_bore/idle only
            print_dbg("Fake reload for empty mag weapon %s, using safe animation", sec)
            if has_animation(sec, "anm_bore") then
                play_hud_animation(weapon, "anm_bore", "snd_bore")
            elseif has_animation(sec, "anm_idle") then
                play_hud_animation(weapon, "anm_idle", nil)
            else
                game.actor_lower_weapon(true)
            end
        else
            -- just lower weapon
            print_dbg("Fake reload for empty mag weapon %s, lowering weapon", sec)
            game.actor_lower_weapon(true)
        end
        return
    end
    
    -- MagsRedux path: handles magazines and chambered rounds properly
    if magazines and is_supported_weapon(sec) then
        local current_magazine = get_mag_loaded(wpn_id)
        
        -- safely get ammo count table
        local pre_table = nil
        if magazines.count_ammo then
            local result = magazines.count_ammo(weapon)
            if type(result) == "table" then
                pre_table = result
            end
        end
        
        -- if one in the chamber, reloading will subtract a box of ammo and create a new dummy mag
        if not current_magazine and magazines.retain_round and magazines.retain_round(weapon) and (current_ammo > 0) then
            local oitc_ammo_sec = magazines.get_sec_chambered(weapon)
            local oitc_ammo_type = weapon:get_ammo_type()
            print_dbg("One (%s: %s) in the chamber and no magazine loaded.", oitc_ammo_type, oitc_ammo_sec)
            weapon:set_ammo_elapsed(0)
            weapon:switch_state(7)
            CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, 1, pre_table, wpn_id)
        else
            weapon:switch_state(7)
            CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, current_ammo, pre_table, wpn_id)
        end
    else
        -- vanilla path: use switch_state since we have ammo (current_ammo > 0 at this point)
        print_dbg("Fake reload for vanilla weapon, ammo count: %s", current_ammo)
        weapon:switch_state(7)
        CreateTimeEvent("AmmoCheck_FakeReload", "dummy_reload"..wpn_id, 0.1, restore_ammo_after_reload, weapon, current_ammo, nil, wpn_id)
    end
end

-- silent ammo check (no weapon hide animation) - used for auto-check after reload
function check_Ammo_silent()
    local actor = db.actor
    if not actor then return end
    
    local weapon = actor:active_item()
    if not weapon then return end
    if not IsWeapon(weapon) then return end
    if IsItem("fake_ammo_wpn", nil, weapon) then return end

    local weaponId = weapon:id()
    local sec = weapon:section()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    if in_grenade_mode and not check_grenade_mode then return end

    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return end

    -- get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    
    -- display directly
    display_ammo_status(message, clr, ammo_type, separate_tag)
end

-- ammo check after reload (for OneKeyReload compatibility)
-- shows "Loaded" message after reload completes
function check_ammo_after_reload()
    local actor = db.actor
    if not actor then return true end
    
    local weapon = actor:active_item()
    if not weapon then return true end
    if not IsWeapon(weapon) then return true end
    if IsItem("fake_ammo_wpn", nil, weapon) then return true end
    
    local currentState = weapon:get_state()
    if not (currentState == 0 or weapon:weapon_in_grenade_mode()) then
        return false  -- still reloading, try again
    end
    
    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return true end
    
    local weaponId = weapon:id()
    local sec = weapon:section()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    -- get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)
    
    disable_info("sleep_active")
    
    -- display with "Loaded" prefix
    if message then
        local loaded_msg = game.translate_string("st_ac_loaded") .. " " .. message
        if show_ammo_type and ammo_type then
            if separate_tag then
                loaded_msg = loaded_msg .. " " .. ammo_type
            else
                loaded_msg = ammo_type .. " " .. loaded_msg
            end
        end
        actor_menu.set_msg(1, loaded_msg, msg_duration, use_clr and clr or nil)
    end
    
    return true
end

-- ### WEAPON CONFIGURATION
-- weapon exclusion lists are defined in ammo_check_weapons.script

local function get_break_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_break_action_config then
        return ammo_check_weapons.get_break_action_config(sec)
    end
    return nil
end

local function get_bolt_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_bolt_action_config then
        return ammo_check_weapons.get_bolt_action_config(sec)
    end
    return nil
end

local function get_pump_action_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_pump_action_config then
        return ammo_check_weapons.get_pump_action_config(sec)
    end
    return nil
end

local function get_pistol_smg_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_pistol_smg_config then
        return ammo_check_weapons.get_pistol_smg_config(sec)
    end
    return nil
end

local function get_rifle_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_rifle_config then
        return ammo_check_weapons.get_rifle_config(sec)
    end
    return nil
end

local function get_sniper_config(sec)
    if ammo_check_weapons and ammo_check_weapons.get_sniper_config then
        return ammo_check_weapons.get_sniper_config(sec)
    end
    return nil
end

local function should_ignore_fake_animations(sec)
    if ammo_check_weapons and ammo_check_weapons.should_ignore_fake_animations then
        return ammo_check_weapons.should_ignore_fake_animations(sec)
    end
    return false
end

local function should_exclude_shell_eject(sec)
    if ammo_check_weapons and ammo_check_weapons.should_exclude_shell_eject then
        return ammo_check_weapons.should_exclude_shell_eject(sec)
    end
    return false
end

-- main ammo check function
function check_Ammo(skip_animation)
    local actor = db.actor
    if not actor then return end
    
    local weapon = actor:active_item()
    
    -- validation checks with early returns
    if not weapon then return end
    if not IsWeapon(weapon) then return end
    if IsItem("fake_ammo_wpn", nil, weapon) then return end

    local weaponId = weapon:id()
    local sec = weapon:section()
    local currentState = weapon:get_state()
    local in_grenade_mode = weapon:weapon_in_grenade_mode()
    
    -- if weapon is busy (animation playing), just show message without animation
    local weapon_busy = (currentState ~= 0)
    
    -- if in grenade mode and check is disabled, return
    if in_grenade_mode and not check_grenade_mode then return end

    local currentAmmo = weapon:get_ammo_in_magazine()
    if not currentAmmo then return end

    -- get ammo status using shared function
    local message, clr, ammo_type, separate_tag = get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo)

    disable_info("sleep_active")

    -- store in globals for TimeEvent access
    ac_pending_message = message
    ac_pending_clr = clr
    ac_pending_ammo_type = ammo_type
    ac_pending_separate_tag = separate_tag

    -- cleanup previous events
    RemoveTimeEvent("ammo_check", "message_delay")
    RemoveTimeEvent("ammo_check", "restore_weapon")
    RemoveTimeEvent("ammo_check", "restore_det")
    RemoveTimeEvent("AmmoCheck_BoltCycle", "close"..weaponId)
    
    -- clear any lingering animation state
    do_ammo_check_anim = nil
    wpn_checking = nil
    
    -- ### ANIMATION LOGIC
    
    -- check if weapon has PROPER custom mag inspect animation
    local has_proper_inspect = has_animation(sec, "anm_ammo_check") or 
                               has_animation(sec, "anm_ammo_check_empty") or
                               has_animation(sec, "anm_ammo_check_no_mag")
    
    -- if weapon busy or skip requested: just show message
    if skip_animation or weapon_busy then
        CreateTimeEvent("ammo_check", "message_delay", 0, delayed_display_callback)
        return
    end
    
    -- if animations are disabled: just show message with delay
    if not enable_animations then
        print_dbg("Ammo check for %s - animations disabled, showing message only.", sec)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- [ A) weapon HAS proper mag inspect animation ]--
    if has_proper_inspect then
        -- check if we need to apply no_magazine_fallback
        local uses_magazines = magazines and is_supported_weapon(sec)
        local needs_no_mag_fallback = false
        
        if uses_magazines then
            local has_detachable_mag = magazine_binder and magazine_binder.weapon_default_magazine and 
                                       magazine_binder.weapon_default_magazine(weapon)
            if has_detachable_mag then
                local current_magazine = get_mag_loaded(weaponId)
                if not current_magazine then
                    needs_no_mag_fallback = true
                end
            end
        end
        
        if needs_no_mag_fallback then
            -- weapon has proper inspect but NO magazine - cancel animation and apply fallback
            print_dbg("Ammo check for %s - has proper inspect but no mag, cancelling and using no_magazine_fallback=%s.", sec, no_magazine_fallback)
            
            -- cancel any started animation and camera effects
            if level.stop_hud_motion then
                level.stop_hud_motion()
            end
            weapon:switch_state(0)  -- switch to idle
            
            -- remove weapon camera effectors (they use random IDs 5000-10000)
            if level.check_cam_effector and level.remove_cam_effector then
                for id = 5000, 10000 do
                    if level.check_cam_effector(id) then
                        level.remove_cam_effector(id)
                    end
                end
            end
            
            -- apply no_magazine_fallback
            if no_magazine_fallback == 0 then
                -- hide/show weapon
                ac_pending_slot = actor:active_slot()
                actor:activate_slot(0)
                weapon_hidden = true
                CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
            elseif no_magazine_fallback == 1 then
                -- lower weapon
                game.actor_lower_weapon(true)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
            else
                -- none - just show message
                CreateTimeEvent("ammo_check", "message_delay", 0, delayed_display_callback)
            end
            return
        end
        
        -- has proper inspect and magazine is loaded (or internal mag) - let native animation play
        print_dbg("Ammo check for %s - has proper inspect animation, NOT interfering.", sec)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- [ B) weapon DOES NOT have proper mag inspect ]--
    
    -- B.1) default mode: hide/show weapon
    if anim_mode == 0 then
        print_dbg("Ammo check for %s - using hide/show weapon.", sec)
        ac_pending_slot = actor:active_slot()
        actor:activate_slot(0)
        weapon_hidden = true
        CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
        return
    end
    
    -- B.2) lower weapon mode
    if anim_mode == 1 then
        print_dbg("Ammo check for %s - using lower weapon.", sec)
        game.actor_lower_weapon(true)
        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        return
    end
    
    -- B.3) fake reload mode
    if anim_mode == 2 then
        -- check if weapon should be ignored for fake reload animations
        if fake_reload_ignore_list and should_ignore_fake_animations(sec) then
            print_dbg("Ammo check for %s - in ignore list, using fake_reload_fallback=%s.", sec, fake_reload_fallback)
            
            if fake_reload_fallback == 0 then
                -- hide/show weapon
                ac_pending_slot = actor:active_slot()
                actor:activate_slot(0)
                weapon_hidden = true
                CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
            else
                -- lower weapon
                game.actor_lower_weapon(true)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
            end
            return
        end
        
        -- check if weapon uses detachable magazines (MagsRedux supported)
        local uses_magazines = magazines and is_supported_weapon(sec)
        
        if uses_magazines then
            -- check if this is a DETACHABLE magazine weapon vs INTERNAL magazine (tube, etc.)
            -- weapon_default_magazine returns nil for internal magazine weapons
            local has_detachable_mag = magazine_binder and magazine_binder.weapon_default_magazine and 
                                       magazine_binder.weapon_default_magazine(weapon)
            
            if has_detachable_mag then
                -- DETACHABLE magazine weapon - check if magazine is actually loaded
                local current_magazine = get_mag_loaded(weaponId)
                
                if current_magazine then
                    -- before using fake reload, check if weapon has custom animation override
                    local custom_config = get_pistol_smg_config(sec) or get_rifle_config(sec) or get_sniper_config(sec)
                    
                    if custom_config then
                        if custom_config.anim and has_animation(sec, custom_config.anim) then
                            print_dbg("Ammo check for %s - using custom %s animation (override).", sec, custom_config.anim)
                            
                            do_ammo_check_anim = 1
                            is_fake_reload = true
                            
                            det_active = actor:active_detector() or nil
                            if det_active then
                                det_active:switch_state(2)
                            end
                            
                            play_hud_animation(weapon, custom_config.anim, custom_config.sound)
                            CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                            CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                            return
                        elseif custom_config.delay and has_animation(sec, "anm_open") and has_animation(sec, "anm_close") then
                            print_dbg("Ammo check for %s - using open/close with %.2fs delay (override).", sec, custom_config.delay)
                            
                            do_ammo_check_anim = 1
                            is_fake_reload = true
                            
                            det_active = actor:active_detector() or nil
                            if det_active then
                                det_active:switch_state(2)
                            end
                            
                            play_open_close_animation(weapon, custom_config.delay)
                            CreateTimeEvent("ammo_check", "message_delay", custom_config.delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                            return
                        end
                    end
                    
                    -- has magazine, no custom override - play fake reload animation
                    print_dbg("Ammo check for %s - detachable mag weapon with mag, using fake reload animation.", sec)
                    
                    do_ammo_check_anim = 1  -- mark that we're doing our own animation
                    is_fake_reload = true   -- prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    play_reload_animation(weapon)
                    CreateTimeEvent("ammo_check", "message_delay", FAKE_RELOAD_MSG_DELAY, delayed_display_callback)
                    return
                else
                    -- no magazine loaded - apply no_magazine_fallback
                    print_dbg("Ammo check for %s - detachable mag weapon, no mag, using no_magazine_fallback=%s.", sec, no_magazine_fallback)
                    
                    if no_magazine_fallback == 0 then
                        -- hide/show weapon
                        ac_pending_slot = actor:active_slot()
                        actor:activate_slot(0)
                        weapon_hidden = true
                        CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
                    elseif no_magazine_fallback == 1 then
                        -- lower weapon
                        game.actor_lower_weapon(true)
                        CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                    else
                        -- none - just show message, no animation
                        CreateTimeEvent("ammo_check", "message_delay", 0, delayed_display_callback)
                    end
                    return
                end
            end
            -- else: internal magazine weapon - fall through to exclusion lists below
            print_dbg("Ammo check for %s - internal magazine weapon (MagsRedux), checking exclusion lists.", sec)
        end
        
        -- [ weapon does NOT use detachable magazines ]--
        
        -- check 1: break-action shotgun (TOZ-34 style)
        local break_config = get_break_action_config(sec)
        if break_config and has_animation(sec, break_config.anim) then
            print_dbg("Ammo check for %s - break-action, using %s animation.", sec, break_config.anim)
            
            do_ammo_check_anim = 1  -- mark that we're doing our own animation
            is_fake_reload = true   -- prevent auto-check duplicate
            
            det_active = actor:active_detector() or nil
            if det_active then
                det_active:switch_state(2)
            end
            
            if play_hud_animation(weapon, break_config.anim, break_config.sound) then
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                return
            else
                -- animation failed, restore state and fall through to fallback
                print_dbg("Animation failed for %s, falling back", sec)
                do_ammo_check_anim = nil
                is_fake_reload = false
                if det_active then
                    db.actor:show_detector(true)
                    det_active = nil
                end
                -- continue to fallback
            end
        end
        
        -- check 2: bolt-action rifle (if MCM option enabled)
        if fake_reload_bolt_cycle then
            local bolt_config = get_bolt_action_config(sec)
            if bolt_config then
                local use_custom_anim = bolt_config.anim and has_animation(sec, bolt_config.anim)
                local use_open_close = has_animation(sec, "anm_open") and has_animation(sec, "anm_close")
                local delay = bolt_config.delay or 0.7  -- default delay if not specified
                
                -- priority 1: use custom animation if specified and exists
                if use_custom_anim then
                    print_dbg("Ammo check for %s - bolt-action, using custom %s animation.", sec, bolt_config.anim)
                    
                    do_ammo_check_anim = 1  -- mark that we're doing our own animation
                    is_fake_reload = true   -- prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    -- eject one round if option enabled and there's ammo
                    if fake_reload_bolt_eject and currentAmmo > 0 then
                        local ammo_section = get_vanilla_ammo_section(weapon)
                        if ammo_section then
                            weapon:set_ammo_elapsed(currentAmmo - 1)
                            alife_create_item(ammo_section, actor)
                            print_dbg("Ejected round: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                            ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                                get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                        end
                    end
                    
                    play_hud_animation(weapon, bolt_config.anim, bolt_config.sound)
                    CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                    CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                    return
                    
                -- priority 2: use anm_open/anm_close (either as configured or as fallback)
                elseif use_open_close then
                    print_dbg("Ammo check for %s - bolt-action, using open/close with %.2fs delay.", sec, delay)
                    
                    do_ammo_check_anim = 1  -- mark that we're doing our own animation
                    is_fake_reload = true   -- prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    -- eject one round if option enabled and there's ammo
                    if fake_reload_bolt_eject and currentAmmo > 0 then
                        local ammo_section = get_vanilla_ammo_section(weapon)
                        if ammo_section then
                            weapon:set_ammo_elapsed(currentAmmo - 1)
                            alife_create_item(ammo_section, actor)
                            print_dbg("Ejected round: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                            ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                                get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                        end
                    end
                    
                    play_open_close_animation(weapon, delay)
                    CreateTimeEvent("ammo_check", "message_delay", delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                    return
                end
            end
        end
        
        -- check 3: pump-action shotgun (if MCM option enabled)
        if fake_reload_pump_rack then
            local pump_config = get_pump_action_config(sec)
            if pump_config then
                local use_custom_anim = pump_config.anim and has_animation(sec, pump_config.anim)
                local use_open_close = has_animation(sec, "anm_open") and has_animation(sec, "anm_close")
                local delay = pump_config.delay or 0.5  -- default delay if not specified
                
                -- priority 1: use custom animation if specified and exists
                if use_custom_anim then
                    print_dbg("Ammo check for %s - pump-action, using custom %s animation.", sec, pump_config.anim)
                    
                    do_ammo_check_anim = 1  -- mark that we're doing our own animation
                    is_fake_reload = true   -- prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    -- eject one shell if option enabled, there's ammo, and weapon not excluded
                    if fake_reload_pump_eject and currentAmmo > 0 and not should_exclude_shell_eject(sec) then
                        local ammo_section = get_vanilla_ammo_section(weapon)
                        if ammo_section then
                            weapon:set_ammo_elapsed(currentAmmo - 1)
                            alife_create_item(ammo_section, actor)
                            print_dbg("Ejected shell: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                            ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                                get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                        end
                    end
                    
                    play_hud_animation(weapon, pump_config.anim, pump_config.sound)
                    CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                    CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                    return
                    
                -- priority 2: use anm_open/anm_close (either as configured or as fallback)
                elseif use_open_close then
                    print_dbg("Ammo check for %s - pump-action, using open/close with %.2fs delay.", sec, delay)
                    
                    do_ammo_check_anim = 1  -- mark that we're doing our own animation
                    is_fake_reload = true   -- prevent auto-check duplicate
                    
                    det_active = actor:active_detector() or nil
                    if det_active then
                        det_active:switch_state(2)
                    end
                    
                    -- eject one shell if option enabled, there's ammo, and weapon not excluded
                    if fake_reload_pump_eject and currentAmmo > 0 and not should_exclude_shell_eject(sec) then
                        local ammo_section = get_vanilla_ammo_section(weapon)
                        if ammo_section then
                            weapon:set_ammo_elapsed(currentAmmo - 1)
                            alife_create_item(ammo_section, actor)
                            print_dbg("Ejected shell: %s (remaining: %d)", ammo_section, currentAmmo - 1)
                            ac_pending_message, ac_pending_clr, ac_pending_ammo_type, ac_pending_separate_tag = 
                                get_ammo_status(weapon, weaponId, sec, in_grenade_mode, currentAmmo - 1)
                        end
                    end
                    
                    play_open_close_animation(weapon, delay)
                    CreateTimeEvent("ammo_check", "message_delay", delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                    return
                end
            end
        end
        
        -- check 4: pistol/SMG with custom animation
        local pistol_config = get_pistol_smg_config(sec)
        if pistol_config then
            local use_custom_anim = pistol_config.anim and has_animation(sec, pistol_config.anim)
            local use_open_close = has_animation(sec, "anm_open") and has_animation(sec, "anm_close")
            local delay = pistol_config.delay or 0.4  -- default delay if not specified
            
            if use_custom_anim then
                print_dbg("Ammo check for %s - pistol/smg, using custom %s animation.", sec, pistol_config.anim)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_hud_animation(weapon, pistol_config.anim, pistol_config.sound)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                return
            elseif use_open_close then
                print_dbg("Ammo check for %s - pistol/smg, using open/close with %.2fs delay.", sec, delay)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_open_close_animation(weapon, delay)
                CreateTimeEvent("ammo_check", "message_delay", delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                return
            end
        end
        
        -- check 5: rifle with custom animation
        local rifle_config = get_rifle_config(sec)
        if rifle_config then
            local use_custom_anim = rifle_config.anim and has_animation(sec, rifle_config.anim)
            local use_open_close = has_animation(sec, "anm_open") and has_animation(sec, "anm_close")
            local delay = rifle_config.delay or 0.5  -- default delay if not specified
            
            if use_custom_anim then
                print_dbg("Ammo check for %s - rifle, using custom %s animation.", sec, rifle_config.anim)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_hud_animation(weapon, rifle_config.anim, rifle_config.sound)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                return
            elseif use_open_close then
                print_dbg("Ammo check for %s - rifle, using open/close with %.2fs delay.", sec, delay)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_open_close_animation(weapon, delay)
                CreateTimeEvent("ammo_check", "message_delay", delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                return
            end
        end
        
        -- check 6: sniper rifle with custom animation
        local sniper_config = get_sniper_config(sec)
        if sniper_config then
            local use_custom_anim = sniper_config.anim and has_animation(sec, sniper_config.anim)
            local use_open_close = has_animation(sec, "anm_open") and has_animation(sec, "anm_close")
            local delay = sniper_config.delay or 0.6  -- default delay if not specified
            
            if use_custom_anim then
                print_dbg("Ammo check for %s - sniper, using custom %s animation.", sec, sniper_config.anim)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_hud_animation(weapon, sniper_config.anim, sniper_config.sound)
                CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
                CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                return
            elseif use_open_close then
                print_dbg("Ammo check for %s - sniper, using open/close with %.2fs delay.", sec, delay)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_open_close_animation(weapon, delay)
                CreateTimeEvent("ammo_check", "message_delay", delay + BOLT_PUMP_MSG_OFFSET, delayed_display_callback)
                return
            end
        end
        
        -- [ fallback: weapons not in custom lists ]--
        if empty_mag_fallback == 0 then
            -- try reload animation (using play_hud_motion which doesn't trigger reload logic)
            print_dbg("Ammo check for %s - using reload animation fallback.", sec)
            
            do_ammo_check_anim = 1
            is_fake_reload = true
            
            det_active = actor:active_detector() or nil
            if det_active then
                det_active:switch_state(2)
            end
            
            local current_ammo = weapon:get_ammo_in_magazine()
            if has_animation(sec, "anm_reload") then
                -- temporarily set ammo to 1 so animation_common doesn't switch to anm_reload_empty
                if current_ammo == 0 then
                    weapon:set_ammo_elapsed(1)
                end
                -- use state=7 to set pending flag (prevents movement interruption)
                local success, err = pcall(function()
                    weapon:play_hud_motion("anm_reload", true, 7, 1, 0)
                end)
                if current_ammo == 0 then
                    weapon:set_ammo_elapsed(0)  -- restore immediately
                end
                
                if success then
                    -- play sound manually - store it so we can stop on cancel
                    local sound_file = ini_sys:r_string_ex(sec, "snd_reload")
                    if sound_file and sound_file ~= "$no_sound" then
                        -- stop any previous sound
                        if empty_mag_sound and empty_mag_sound:playing() then
                            empty_mag_sound:stop()
                        end
                        empty_mag_sound = sound_object(sound_file)
                        if empty_mag_sound then
                            empty_mag_sound:play(db.actor, 0, sound_object.s2d)
                        end
                    end
                end
            elseif has_animation(sec, "anm_bore") then
                play_hud_animation(weapon, "anm_bore", "snd_bore")
            else
                game.actor_lower_weapon(true)
            end
            
            CreateTimeEvent("ammo_check", "message_delay", FAKE_RELOAD_MSG_DELAY, delayed_display_callback)
            CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
            return
            
        elseif empty_mag_fallback == 1 then
            -- try safe animations (anm_bore/anm_idle)
            local fallback_anim = nil
            local fallback_sound = nil
            
            if has_animation(sec, "anm_bore") then
                fallback_anim = "anm_bore"
                fallback_sound = "snd_bore"
            elseif has_animation(sec, "anm_idle") then
                fallback_anim = "anm_idle"
                fallback_sound = nil
            end
            
            if fallback_anim then
                print_dbg("Ammo check for %s - using %s fallback (no MagsRedux/not in lists).", sec, fallback_anim)
                
                do_ammo_check_anim = 1
                is_fake_reload = true
                
                det_active = actor:active_detector() or nil
                if det_active then
                    det_active:switch_state(2)
                end
                
                play_hud_animation(weapon, fallback_anim, fallback_sound)
                
                CreateTimeEvent("ammo_check", "message_delay", FAKE_RELOAD_MSG_DELAY, delayed_display_callback)
                CreateTimeEvent("ammo_check", "restore_det", 0.1, restore_detector_after_anim, weapon)
                return
            end
            -- fall through to fake_reload_fallback if no safe animation found
        end
        
        -- [ fallback: use fake_reload_fallback ]--
        if fake_reload_fallback == 0 then
            -- hide/show weapon
            print_dbg("Ammo check for %s - fallback to hide/show weapon.", sec)
            ac_pending_slot = actor:active_slot()
            actor:activate_slot(0)
            weapon_hidden = true
            CreateTimeEvent("ammo_check", "restore_weapon", 0, restore_weapon_callback)
        else
            -- lower weapon
            print_dbg("Ammo check for %s - fallback to lower weapon.", sec)
            game.actor_lower_weapon(true)
            CreateTimeEvent("ammo_check", "message_delay", busy_hands_delay, delayed_display_callback)
        end
        return
    end
end

-- news system with deduplication
local old_news = {}

function give_news(message)
    if old_news[message] then return end
    old_news[message] = true

    print_dbg(message)
    if db.actor then
        db.actor:give_game_news("AmmoCheck", message, "ui_inGame2_D_Ohotnik_na_mutantov", 0, 5000, 0)
    end
end
